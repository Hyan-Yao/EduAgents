\documentclass[aspectratio=169]{beamer}

% Theme and Color Setup
\usetheme{Madrid}
\usecolortheme{whale}
\useinnertheme{rectangles}
\useoutertheme{miniframes}

% Additional Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}
\usetikzlibrary{positioning}
\usepackage{hyperref}

% Custom Colors
\definecolor{myblue}{RGB}{31, 73, 125}
\definecolor{mygray}{RGB}{100, 100, 100}
\definecolor{mygreen}{RGB}{0, 128, 0}
\definecolor{myorange}{RGB}{230, 126, 34}
\definecolor{mycodebackground}{RGB}{245, 245, 245}

% Set Theme Colors
\setbeamercolor{structure}{fg=myblue}
\setbeamercolor{frametitle}{fg=white, bg=myblue}
\setbeamercolor{title}{fg=myblue}
\setbeamercolor{section in toc}{fg=myblue}
\setbeamercolor{item projected}{fg=white, bg=myblue}
\setbeamercolor{block title}{bg=myblue!20, fg=myblue}
\setbeamercolor{block body}{bg=myblue!10}
\setbeamercolor{alerted text}{fg=myorange}

% Set Fonts
\setbeamerfont{title}{size=\Large, series=\bfseries}
\setbeamerfont{frametitle}{size=\large, series=\bfseries}
\setbeamerfont{caption}{size=\small}
\setbeamerfont{footnote}{size=\tiny}

% Footer and Navigation Setup
\setbeamertemplate{footline}{
  \leavevmode%
  \hbox{%
  \begin{beamercolorbox}[wd=.3\paperwidth,ht=2.25ex,dp=1ex,center]{author in head/foot}%
    \usebeamerfont{author in head/foot}\insertshortauthor
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.25ex,dp=1ex,center]{title in head/foot}%
    \usebeamerfont{title in head/foot}\insertshorttitle
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.2\paperwidth,ht=2.25ex,dp=1ex,center]{date in head/foot}%
    \usebeamerfont{date in head/foot}
    \insertframenumber{} / \inserttotalframenumber
  \end{beamercolorbox}}%
  \vskip0pt%
}

% Turn off navigation symbols
\setbeamertemplate{navigation symbols}{}

% Title Page Information
\title[Chapter 3-4]{Chapter 3-4: Search Algorithms and Constraint Satisfaction Problems}
\author[J. Smith]{John Smith, Ph.D.}
\institute[University Name]{
  Department of Computer Science\\
  University Name\\
  \vspace{0.3cm}
  Email: email@university.edu\\
  Website: www.university.edu
}
\date{\today}

% Document Start
\begin{document}

\frame{\titlepage}

\begin{frame}[fragile]
    \frametitle{Introduction to Search Algorithms and CSPs}
    An overview of search algorithms and Constraint Satisfaction Problems (CSPs) in AI.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Overview of Search Algorithms}
    Search algorithms are fundamental tools used in AI to explore and navigate solutions in large search spaces.
    \begin{itemize}
        \item Systematically explore potential solutions to find one or more goals.
    \end{itemize}
    
    \begin{block}{Types of Search Algorithms}
        \begin{enumerate}
            \item \textbf{Uninformed Search:}
                \begin{itemize}
                    \item These algorithms do not have additional information about the state space.
                    \item \textbf{Examples:}
                        \begin{itemize}
                            \item \textbf{Breadth-First Search (BFS)}: Explores all nodes at the current depth before moving deeper.
                            \item \textbf{Depth-First Search (DFS)}: Explores as far down a branch as possible before backtracking.
                        \end{itemize}
                \end{itemize}
            \item \textbf{Informed Search:}
                \begin{itemize}
                    \item These algorithms use heuristics to guide the search, improving efficiency.
                    \item \textbf{Example:} A* Algorithm, which combines the cost to reach a node and an estimated cost to reach the goal.
                \end{itemize}
        \end{enumerate}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Overview of Constraint Satisfaction Problems (CSPs)}
    CSPs are mathematical problems defined by a set of objects whose state must satisfy several constraints and conditions.
    
    \begin{block}{Key Components of CSPs}
        \begin{enumerate}
            \item \textbf{Variables:} The entities we want to assign values to.
            \item \textbf{Domains:} The possible values each variable can take.
            \item \textbf{Constraints:} Rules that restrict the values that variables can simultaneously take.
        \end{enumerate}
    \end{block}

    \begin{block}{Example of a CSP}
        \begin{itemize}
            \item \textbf{Sudoku Puzzle:} Each cell (variable) must have a value from 1 to 9 (domain) such that no number repeats in any row, column, or sub-grid (constraints).
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Points and Conclusion}
    \begin{itemize}
        \item Search algorithms are vital for exploring solution spaces in various applications, from puzzles to complex AI problems like game playing and scheduling.
        \item CSPs provide a framework for problems needing multiple conditions to be satisfied, leading to efficient problem-solving strategies.
        \item The combination of search algorithms and CSP techniques optimizes problem-solving in real-world applications (e.g., resource allocation, scheduling).
    \end{itemize}
    
    \textbf{Conclusion:} Understanding search algorithms and CSPs equips students with essential tools to tackle a wide array of AI challenges.
    
    \textbf{Next Steps:} In the following slides, we will discuss the importance of search in AI and dive deeper into specific algorithms and their applications.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Importance of Search in AI - Introduction}
    \begin{block}{Overview}
        Search is a fundamental aspect of artificial intelligence (AI) that enables machines to:
        \begin{itemize}
            \item Navigate complex problems
            \item Find solutions
            \item Make decisions based on vast amounts of data
        \end{itemize}
        Search algorithms serve as the backbone of many AI applications, from game-playing bots to optimization problems.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Importance of Search in AI - Why Search is Critical}
    \begin{enumerate}
        \item \textbf{Problem Solving}
        \begin{itemize}
            \item Definition: Strategies to explore potential solutions efficiently.
            \item Example: In chess, an AI explores various possible moves to determine the best action.
        \end{itemize}
        
        \item \textbf{Navigating Large Search Spaces}
        \begin{itemize}
            \item Definition: Exploring a vast number of possibilities in a "search space."
            \item Example: The traveling salesman problem requires finding the shortest route through numerous potential routes.
        \end{itemize}
        
        \item \textbf{Uncertainty Handling}
        \begin{itemize}
            \item Definition: Addressing uncertainty and incomplete information in real-world problems.
            \item Example: Robotics use search algorithms to map environments based on sensor data.
        \end{itemize}
        
        \item \textbf{Efficiency and Optimization}
        \begin{itemize}
            \item Definition: Finding optimal solutions within constraints.
            \item Example: A* and Dijkstra's algorithms determine the most efficient route considering various criteria.
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Example of a Search Algorithm: A* Algorithm}
    \begin{block}{A* Algorithm}
        The A* algorithm is widely used in AI for pathfinding and graph traversal.
        \begin{equation}
            f(n) = g(n) + h(n)
        \end{equation}
        where:
        \begin{itemize}
            \item $f(n)$: Total estimated cost of the cheapest solution through node $n$.
            \item $g(n)$: Cost from the start node to node $n$.
            \item $h(n)$: Heuristic estimated cost from node $n$ to the goal.
        \end{itemize}
    \end{block}
    
    \begin{block}{Illustration}
        Consider a grid-based map where A* is used to find the shortest path from start to finish. The algorithm evaluates nodes using the $f(n)$ formula, expanding the least costly nodes first.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Importance of Search in AI - Conclusion}
    \begin{block}{Final Remarks}
        Search is not just a component of AI; it drives problem-solving capabilities across diverse domains. 
        \begin{itemize}
            \item Effective search strategies are essential for developing intelligent systems.
            \item Understanding search algorithms enables tackling real-world challenges.
        \end{itemize}
    \end{block}
    
    \begin{block}{Next Steps}
        In the next slide, we will explore different types of search algorithms, their mechanisms, and applicable scenarios, enhancing our understanding of AI search techniques.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Types of Search Algorithms - Overview}
    \begin{block}{Overview of Search Algorithms}
        Search algorithms are fundamental techniques used in AI to explore problem spaces and find solutions. 
        Understanding various types is essential for efficiency in complex data environments.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Types of Search Algorithms - Uninformed and Informed}
    \begin{block}{1. Uninformed Search Algorithms}
        These algorithms explore the search space without additional information about the goal's location.
        \begin{itemize}
            \item \textbf{Breadth-First Search (BFS)}: Explores all nodes at the present depth before moving deeper.
                \begin{itemize}
                    \item \textit{Example:} Finding the shortest path in an unweighted graph.
                \end{itemize}
            \item \textbf{Depth-First Search (DFS)}: Explores as far down a branch as possible before backtracking.
                \begin{itemize}
                    \item \textit{Example:} Solving a maze by exploring until hitting a wall.
                \end{itemize}
        \end{itemize}
        \begin{block}{2. Informed Search Algorithms}
            Also known as heuristic search; these algorithms use additional information to locate goals efficiently.
            \begin{itemize}
                \item \textbf{A* Search}: Combines BFS and DFS, using a heuristic function \( h(n) \) to estimate costs.
                    \begin{equation}
                        f(n) = g(n) + h(n)
                    \end{equation}
                    \item \textit{Application:} Common in pathfinding algorithms like Google Maps.
                \item \textbf{Greedy Best-First Search}: Chooses the path closest to the goal based on heuristics.
                    \begin{itemize}
                        \item \textit{Note:} May not produce the shortest path.
                    \end{itemize}
            \end{itemize}
        \end{block}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Types of Search Algorithms - Local Search and Key Points}
    \begin{block}{3. Local Search Algorithms}
        These algorithms search the space of potential solutions directly.
        \begin{itemize}
            \item \textbf{Hill Climbing}: Moves toward increasing values (or decreasing costs), risks local maxima.
                \begin{itemize}
                    \item \textit{Application:} Function optimization tasks.
                \end{itemize}
            \item \textbf{Simulated Annealing}: Uses probability to escape local maxima in search for global optimum.
        \end{itemize}
    \end{block}

    \begin{block}{Key Points to Emphasize}
        \begin{itemize}
            \item \textbf{Trade-offs}: Uninformed algorithms are simple but less efficient than informed algorithms.
            \item \textbf{Complexity}: Efficiency varies based on problem structure.
            \item \textbf{Applications}: Each type caters to specific scenarios like pathfinding, games, etc.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Depth-First Search (DFS) - Overview}
    \begin{block}{Explanation of Depth-First Search}
        Depth-First Search (DFS) is a fundamental search algorithm used to explore nodes and edges of a graph or tree data structure. It operates by traversing as far down a branch as possible before backtracking.
    \end{block}
    
    \begin{block}{Applications}
        \begin{itemize}
            \item Pathfinding
            \item Topological Sorting
            \item Cycle Detection
            \item Solving Puzzles
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Depth-First Search (DFS) - Process}
    \begin{enumerate}
        \item \textbf{Initialization}:
            \begin{itemize}
                \item Start with a selected node (root).
                \item Use a stack data structure to track nodes to be explored.
            \end{itemize}
        \item \textbf{Exploration}:
            \begin{itemize}
                \item Push the starting node onto the stack.
                \item Pop a node from the stack, check if it is the target.
                \item If not, mark as visited and push unvisited adjacent nodes.
            \end{itemize}
        \item \textbf{Backtracking}:
            \begin{itemize}
                \item If there are no unvisited adjacent nodes, backtrack by popping.
                \item Continue until target is found or all nodes are explored.
            \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Depth-First Search (DFS) - Pseudocode}
    \begin{lstlisting}[language=Python]
def depth_first_search(graph, start):
    stack = [start]
    visited = set()  # To keep track of visited nodes

    while stack:
        node = stack.pop()
        if node not in visited:
            print(node)  # Process the node (e.g., print it)
            visited.add(node)  # Mark node as visited
            for neighbor in graph[node]:  # Explore adjacents
                if neighbor not in visited:
                    stack.append(neighbor)
    \end{lstlisting}
\end{frame}

\begin{frame}
    \frametitle{Depth-First Search (DFS) - Complexity}
    \begin{block}{Key Points}
        \begin{itemize}
            \item \textbf{Time Complexity}: \(O(V + E)\), where \(V\) is the number of vertices and \(E\) is the number of edges.
            \item \textbf{Space Complexity}: \(O(V)\) for the stack in the worst case, especially for deep trees.
            \item \textbf{Recursive Implementation}: Can simplify code but may lead to stack overflow for very deep trees.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Breadth-First Search (BFS) - Overview}
    \begin{block}{Overview}
        Breadth-First Search (BFS) is a fundamental graph traversal algorithm that explores nodes and edges in a systematic manner. It begins at a specific source node, examining all neighboring nodes at the present depth before progressing to the next level. This method ensures the shortest path discovery in unweighted graphs.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{BFS - Key Concepts}
    \begin{itemize}
        \item \textbf{Graph Representation:}
            \begin{itemize}
                \item Adjacency List: Efficient in terms of space.
                \item Adjacency Matrix: Useful for dense graphs, but requires more storage.
            \end{itemize}
        \item \textbf{Queue Data Structure:}
            \begin{itemize}
                \item BFS utilizes a queue to track nodes for exploration.
                \item Nodes are enqueued upon discovery and dequeued for processing.
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{BFS - Algorithm Steps}
    \begin{enumerate}
        \item Start with a source node, mark it as visited, and enqueue it.
        \item While the queue is not empty:
            \begin{itemize}
                \item Dequeue a node and process it (e.g., print or perform an operation).
                \item For each unvisited neighbor of the current node:
                    \begin{itemize}
                        \item Mark it as visited.
                        \item Enqueue it.
                    \end{itemize}
            \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{BFS - Pseudocode}
    \begin{center}
        \texttt{
            BFS(graph, start\_node): \\ 
            \quad create a queue Q \\ 
            \quad mark start\_node as visited \\ 
            \quad enqueue start\_node into Q \\ 
            \\ 
            \quad while Q is not empty: \\ 
            \quad \quad current\_node = dequeue from Q \\ 
            \quad \quad process(current\_node) \\ 
            \\ 
            \quad \quad for each neighbor in graph.get\_neighbors(current\_node): \\ 
            \quad \quad \quad if neighbor is not visited: \\ 
            \quad \quad \quad \quad mark neighbor as visited \\ 
            \quad \quad \quad \quad enqueue neighbor into Q
        }
    \end{center}
\end{frame}

\begin{frame}[fragile]
    \frametitle{BFS - Example}
    \begin{block}{Example Graph}
        \texttt{
            A \\ 
            / \backslash \\
            B \quad C \\ 
            | \quad | \\ 
            D - E
        }
    \end{block}
    \begin{itemize}
        \item Using BFS starting from node A:
        \begin{itemize}
            \item Level 1: A
            \item Level 2: B, C
            \item Level 3: D, E
        \end{itemize}
        \item \textbf{Traversal Order (BFS):} A, B, C, D, E
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{BFS - Advantages and Use Cases}
    \begin{block}{Advantages}
        \begin{itemize}
            \item \textbf{Completeness:} Guaranteed to find a solution in finite graphs.
            \item \textbf{Optimality:} Finds the shortest path in unweighted graphs.
            \item \textbf{Simplicity:} Easy to implement and understand.
        \end{itemize}
    \end{block}

    \begin{block}{Use Cases}
        \begin{itemize}
            \item Pathfinding Algorithms in networking.
            \item Analyzing Social Networks for connections.
            \item Efficient Web Crawlers for traversing web pages.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{BFS - Conclusion}
    \begin{block}{Conclusion}
        Breadth-First Search is a powerful and versatile algorithm with applications in various fields, including computer networking and artificial intelligence. Understanding its mechanics and advantages is crucial for selecting the right algorithm for specific problems.
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Comparing DFS and BFS}
    \begin{block}{Overview}
        Depth-First Search (DFS) and Breadth-First Search (BFS) are foundational algorithms for traversing or searching through trees and graphs.
        Understanding their differences is crucial for selecting the appropriate algorithm for a specific problem.
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Key Differences - Part 1}
    \begin{enumerate}
        \item \textbf{Approach}:
        \begin{itemize}
            \item \textbf{DFS}:
            \begin{itemize}
                \item Explores as far as possible along each branch before backtracking.
                \item Utilizes a stack (either implicitly via recursion or explicitly).
            \end{itemize}
            \item \textbf{BFS}:
            \begin{itemize}
                \item Explores all neighbors at the present depth prior to moving to nodes at the next depth level.
                \item Utilizes a queue.
            \end{itemize}
        \end{itemize}
        
        \item \textbf{Traversal Order}:
        \begin{itemize}
            \item \textbf{DFS}: Depth-wise manner (e.g., Start at A → B → D → B → E → A → C).
            \item \textbf{BFS}: Level by level (e.g., Start at A → B, C → D, E (from B), F (from C)).
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}
    \frametitle{Key Differences - Part 2}
    \begin{enumerate}
        \setcounter{enumi}{2}
        \item \textbf{Space Complexity}:
        \begin{itemize}
            \item \textbf{DFS}: O(h), where h is the maximum depth (typically requires less memory).
            \item \textbf{BFS}: O(w), where w is the maximum width (can consume more memory).
        \end{itemize}
        
        \item \textbf{Use Cases}:
        \begin{itemize}
            \item \textbf{DFS}:
            \begin{itemize}
                \item Suitable for exhaustive search applications.
                \item Used in topological sorting, maze solving, and finding strongly connected components.
            \end{itemize}
            \item \textbf{BFS}:
            \begin{itemize}
                \item Ideal for shortest path in unweighted graphs.
                \item Commonly used in social networking, GPS systems, and broadcasting.
            \end{itemize}
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}
    \frametitle{Example Scenario}
    \begin{block}{Finding the Shortest Path}
        \textbf{Problem}: Given a graph representing a city, find the shortest route from home (A) to grocery store (G).
        \begin{itemize}
            \item \textbf{With BFS}: Guarantees the shortest path due to level-wise exploration.
            \item \textbf{With DFS}: May not find the shortest path efficiently.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Code Snippet Example}
    \textbf{DFS Implementation in Python}:
    \begin{lstlisting}[language=Python]
def dfs(graph, start, visited=set()):
    visited.add(start)
    print(start)
    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
    \end{lstlisting}

    \vspace{1em}

    \textbf{BFS Implementation in Python}:
    \begin{lstlisting}[language=Python]
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    
    while queue:
        vertex = queue.popleft()
        if vertex not in visited:
            visited.add(vertex)
            print(vertex)
            queue.extend(set(graph[vertex]) - visited)
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Heuristic Search Techniques}
    \begin{block}{Introduction}
        Heuristic search techniques are methods used in problem-solving and optimization that leverage additional information, known as heuristics, to estimate costs. This allows them to prioritize paths effectively.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Concepts}
    \begin{enumerate}
        \item \textbf{Heuristic Function (h(n)):} Estimates the cost of the cheapest path from node \( n \) to the goal.
        \item \textbf{Evaluation Function (f(n)):} Defined as 
        \begin{equation}
            f(n) = g(n) + h(n)
        \end{equation}
        where 
        \begin{itemize}
            \item \( g(n) \): cost from the start node to node \( n \)
            \item \( h(n) \): estimated cost from node \( n \) to the goal
        \end{itemize}
        \item \textbf{Optimality:} Heuristic search techniques can guarantee optimal solutions under certain conditions, such as using an admissible heuristic in A*.
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{A* Algorithm Overview}
    \begin{block}{Algorithm Steps}
        \begin{itemize}
            \item \textbf{Initialization:} Start with an open set containing the initial node and an empty closed set.
            \item \textbf{Loop:} Until the open set is empty:
            \begin{itemize}
                \item Select node \( n \) with the lowest \( f(n) \) in the open set.
                \item If \( n \) is the goal, reconstruct and return the path.
                \item Move \( n \) to the closed set, expand its neighbors.
                \item Calculate \( g(n) \), \( h(n) \), and \( f(n) \) for each neighbor.
            \end{itemize}
            \item \textbf{End Condition:} The algorithm ends when the goal is found or no nodes remain to explore.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Example of A*}
    \begin{block}{Practical Example}
        In a grid navigation problem:
        \begin{itemize}
            \item Navigate from the top-left corner to the bottom-right corner.
            \item Use the Manhattan distance as a heuristic, which sums the absolute differences of the x and y coordinates.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Conclusion}
    \begin{block}{Takeaways}
        \begin{itemize}
            \item Heuristic search techniques significantly reduce search times by guiding the search process using heuristics.
            \item The A* algorithm effectively balances optimality and computational efficiency.
            \item The choice of heuristic impacts both the speed and quality of the solution.
            \item Understanding these techniques is critical in fields like artificial intelligence and operations research.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Understanding Constraint Satisfaction Problems (CSPs) - Part 1}
    \begin{block}{Definition}
        A Constraint Satisfaction Problem (CSP) is a framework used to solve problems where the goal is to find values for a set of variables that satisfy a number of constraints. These problems can be formally defined as the tuple \((X, D, C)\) where:
    \end{block}
    \begin{itemize}
        \item **X**: Set of variables.
        \item **D**: Set of domains, representing possible values for variables.
        \item **C**: Set of constraints that define allowed value combinations.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Understanding Constraint Satisfaction Problems (CSPs) - Part 2}
    \begin{block}{Key Concepts}
        \begin{itemize}
            \item **Variables**: Elements needing value assignments (e.g., \( X = \{x_1, x_2, x_3\} \)).
            \item **Domains**: Possible values for each variable (e.g., \( D(x_1) = \{1, 2, 3\} \)).
            \item **Constraints**: Rules that restrict values (e.g., \( C = \{x_1 < x_2\} \)).
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Examples of Constraint Satisfaction Problems (CSPs)}
    \begin{enumerate}
        \item **Scheduling**: Assign time slots for classes.
            \begin{itemize}
                \item Variables: Classes
                \item Domains: Time slots
                \item Constraints: No overlaps, teacher availability
            \end{itemize}
        \item **Sudoku**: Fill a 9x9 grid without repetitions.
            \begin{itemize}
                \item Variables: Cells
                \item Domains: Numbers 1-9
                \item Constraints: No repeats in row, column, or block
            \end{itemize}
        \item **Map Coloring**: Color a map such that adjacent areas differ.
            \begin{itemize}
                \item Variables: Map regions
                \item Domains: Colors
                \item Constraints: Adjacent regions differ in color
            \end{itemize}
        \item **N-Queens Problem**: Place N queens so they don’t threaten each other.
            \begin{itemize}
                \item Variables: Positions of queens
                \item Domains: Row and column positions
                \item Constraints: No two queens in the same row, column, or diagonal
            \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Components of CSPs - Introduction}
    \begin{block}{What are CSPs?}
        Constraint Satisfaction Problems (CSPs) are mathematical problems defined as a set of objects whose states must satisfy several constraints. The goal is to find solutions that meet these constraints.
    \end{block}
    \begin{block}{Key Components}
        To understand CSPs better, let's look at their three fundamental components:
        \begin{itemize}
            \item Variables
            \item Domains
            \item Constraints
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Components of CSPs - Variables and Domains}
    \begin{block}{A. Variables}
        \begin{itemize}
            \item \textbf{Definition}: Variables are the unknowns that need assignment of values.
            \item \textbf{Example}: In a map coloring problem, regions (e.g., $A$, $B$, $C$) are treated as variables.
            \item \textbf{Characteristics}: 
            \begin{itemize}
                \item Variables can take on values from a predefined set (domain).
                \item The number of variables affects the problem's complexity.
            \end{itemize}
        \end{itemize}
    \end{block}

    \begin{block}{B. Domains}
        \begin{itemize}
            \item \textbf{Definition}: The domain of a variable is the set of possible values that can be assigned.
            \item \textbf{Example}: Regions in the map can be colored with three colors: \{Red, Green, Blue\}.
            \item \textbf{Key Point}: Narrower domains can make finding solutions easier since they can increase the chance of satisfying constraints.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Components of CSPs - Constraints}
    \begin{block}{C. Constraints}
        \begin{itemize}
            \item \textbf{Definition}: Constraints dictate allowed combinations of variable assignments and define their relationships.
            \item \textbf{Types of Constraints}:
                \begin{itemize}
                    \item \textbf{Unary}: Involves one variable (e.g., Variable $A$ must be Green).
                    \item \textbf{Binary}: Involves two variables (e.g., Variable $A$ cannot be the same color as $B$).
                    \item \textbf{Higher-order}: Involves three or more variables.
                \end{itemize}
            \item \textbf{Example}: For the map coloring problem:
                \begin{itemize}
                    \item $A \neq B$ (Region A must be a different color than Region B).
                \end{itemize}
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Illustration of CSP in a Map Coloring Scenario}
    \begin{block}{CSP Variables, Domains, and Constraints}
        \textbf{Variables}:
        \begin{itemize}
            \item $A$ = Region A
            \item $B$ = Region B
            \item $C$ = Region C
        \end{itemize}

        \textbf{Domains}:
        \begin{itemize}
            \item $D(A) = \{Red, Green, Blue\}$
            \item $D(B) = \{Red, Green, Blue\}$
            \item $D(C) = \{Red, Green, Blue\}$
        \end{itemize}

        \textbf{Constraints}:
        \begin{enumerate}
            \item $A \neq B$ (Region A must differ from Region B)
            \item $A \neq C$ (Region A must differ from Region C)
            \item $B \neq C$ (Region B must differ from Region C)
        \end{enumerate}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Takeaways and Next Steps}
    \begin{block}{Key Takeaways}
        \begin{itemize}
            \item \textbf{Understanding Variables}: Each variable requires value assignment from its domain.
            \item \textbf{Exploring Domains}: Domains shape the system's potential states and impact solution complexity.
            \item \textbf{Defining Constraints}: Constraints govern the conditions that maintain the integrity of variable assignments.
        \end{itemize}
    \end{block}

    \begin{block}{Next Steps}
        Consider methods to systematically address constraints given the variables and domains. This leads us to various techniques for solving CSPs, which will be covered in the next section.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Solving CSPs: Techniques}
    \begin{block}{Overview}
        This presentation covers techniques for solving Constraint Satisfaction Problems (CSPs), focusing on Backtracking and Constraint Propagation.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Backtracking}
    \begin{itemize}
        \item \textbf{Definition}: Systematic exploration of variable assignments to find solutions.
        \item \textbf{Process}:
        \begin{enumerate}
            \item Choose a variable.
            \item Assign a value from the domain.
            \item Check if the assignment satisfies all constraints.
            \item Recur for the next variable; if invalid, backtrack.
        \end{enumerate}
        \item \textbf{Example}: For variables \(X_1\), \(X_2\), \(X_3\) with the constraints \(X_1 \neq X_2\) and \(X_2 \neq X_3\):
        \begin{itemize}
            \item Start: \(X_1 = 1\), then \(X_2 = 2\), \(X_3 = 3\)' → Solution found: \((1, 2, 3)\).
        \end{itemize}
        \item \textbf{Key Points}:
        \begin{itemize}
            \item Simple but can be inefficient without heuristics.
            \item Performance improves with good variable and value ordering.
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Constraint Propagation}
    \begin{itemize}
        \item \textbf{Definition}: Technique that reduces variable domains by enforcing constraints among them.
        \item \textbf{Process}:
        \begin{enumerate}
            \item Start with initial domains of all variables.
            \item Revise domains by updating values in constraints.
            \item Iterate until no changes or inconsistency (empty domain).
        \end{enumerate}
        \item \textbf{Example}: Using the earlier example with initial domains \(D(X_1) = \{1, 2, 3\}\) and updating based on constraints.
        \begin{itemize}
            \item Constraint \(X_1 \neq X_2\) results in \(D(X_2) = \{2, 3\}\) if \(X_1 = 1\).
        \end{itemize}
        \item \textbf{Key Points}:
        \begin{itemize}
            \item Efficient at reducing search space significantly.
            \item Often used as a preprocessing step before search methods.
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Conclusion}
    \begin{block}{Summary}
        Both Backtracking and Constraint Propagation are essential techniques for solving CSPs:
        \begin{itemize}
            \item Backtracking offers a complete search strategy.
            \item Constraint Propagation reduces the search space and often leads to quicker solutions.
        \end{itemize}
        Understanding the application of these methods is crucial for effective problem-solving in CSPs.
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Applications of Search Algorithms}
    \begin{itemize}
        \item Exploration of real-world applications where search algorithms are utilized.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Learning Objectives}
    \begin{itemize}
        \item Understand the real-world significance of search algorithms.
        \item Identify specific domains where search algorithms are applied.
        \item Analyze the impact of search algorithms on problem-solving in various industries.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Explanation of Search Algorithms}
    \begin{block}{Definition}
        Search algorithms are fundamental techniques used to traverse or search through data structures or problem spaces. They systematically explore possibilities until a solution is found or all options are exhausted.
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Key Applications of Search Algorithms}
    \begin{enumerate}
        \item \textbf{Pathfinding in Navigation Systems}
        \begin{itemize}
            \item Search algorithms like A* and Dijkstra's are used in GPS and mapping software to find the shortest path between two points.
            \item \textit{Example:} Google Maps uses A* for driving directions.
        \end{itemize}
        
        \item \textbf{Game Development}
        \begin{itemize}
            \item AI in gaming leverages search algorithms for character movement and decision-making.
            \item \textit{Example:} Chess engines use Minimax algorithm with alpha-beta pruning.
        \end{itemize}
        
        \item \textbf{Robotics and Autonomous Systems}
        \begin{itemize}
            \item Robots use search algorithms to navigate and perform tasks autonomously.
            \item \textit{Example:} Drones optimize flight paths for delivery using search algorithms.
        \end{itemize}
        
        \item \textbf{Artificial Intelligence in Decision-Making}
        \begin{itemize}
            \item AI applies search algorithms for generating solutions to complex problems.
            \item \textit{Example:} Machine learning optimizes model parameters using search techniques.
        \end{itemize}
        
        \item \textbf{Web Search Engines}
        \begin{itemize}
            \item Algorithms like PageRank index and rank web pages based on relevance.
            \item \textit{Example:} Google provides relevant search results by exploring vast information.
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}
    \frametitle{Key Points to Emphasize}
    \begin{itemize}
        \item Search algorithms are versatile and impact various industries.
        \item They optimize efficiency, enhance decision-making, and improve user experiences.
        \item Understanding different search techniques (e.g., depth-first search, breadth-first search, heuristic methods) is crucial for practical applications.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Illustration: A* Search Algorithm Steps}
    \begin{enumerate}
        \item \textbf{Initialize:} Start with an open set containing the initial node and a closed set.
        \item \textbf{Loop Until Goal Found:}
        \begin{itemize}
            \item Extract the node with the lowest cost from the open set.
            \item Calculate costs (g(n), h(n), f(n)).
            \item Explore neighboring nodes, update costs, and track the path.
            \item Move node to closed set once processed.
        \end{itemize}
        \item \textbf{Construct Path:} Backtrack through parent nodes to construct the final path once the goal is reached.
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{A* Algorithm Pseudocode}
    \begin{lstlisting}[language=Python]
def A_star(start, goal):
    open_set = {start}
    came_from = {}
    
    g_score = {node: infinity for node in all_nodes}
    g_score[start] = 0
    
    f_score = {node: infinity for node in all_nodes}
    f_score[start] = heuristic(start, goal)
    
    while open_set:
        current = node in open_set with lowest f_score
        
        if current == goal:
            return reconstruct_path(came_from, current)
        
        open_set.remove(current)
        
        for neighbor in neighbors(current):
            tentative_g_score = g_score[current] + distance(current, neighbor)
            
            if tentative_g_score < g_score[neighbor]:
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, goal)
                if neighbor not in open_set:
                    open_set.add(neighbor)
    
    return failure
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Applications of CSPs - Overview}
    \begin{block}{Key Concepts}
        Constraint Satisfaction Problems (CSPs) involve finding values for variables under a set of constraints. They are prevalent in various real-world applications due to their ability to model complex problems where certain conditions must be met.
    \end{block}
\end{frame}

\begin{frame}[fragile]{Applications of CSPs - Scheduling}
    \begin{itemize}
        \item \textbf{Scheduling:}
        \begin{itemize}
            \item \textbf{Description:} Scheduling problems involve allocating tasks to resources within specified constraints (e.g., time, resource availability).
            \item \textbf{Example:} 
                University course scheduling assigns courses to time slots ensuring no conflicts for students and availability of instructors.
            \item \textbf{Illustration:}
            \begin{itemize}
                \item Variables: Courses (C1, C2, C3)
                \item Domains: Time slots (T1, T2, T3)
                \item Constraints: C1 cannot be scheduled at the same time as C2 if they share students.
            \end{itemize}
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Applications of CSPs - Resource Allocation}
    \begin{itemize}
        \item \textbf{Resource Allocation:}
        \begin{itemize}
            \item \textbf{Description:} Assigning resources to tasks under specific constraints, optimizing for maximum efficiency and minimal waste.
            \item \textbf{Example:} 
                Resource allocation in computing addresses how CPUs and memory are allocated to various processes, ensuring performance and avoiding conflicts.
            \item \textbf{Illustration:}
            \begin{itemize}
                \item Variables: Processes (P1, P2)
                \item Domains: CPU time slots (S1, S2, S3)
                \item Constraints: Each process requires exclusive access to a CPU time slot.
            \end{itemize}
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Applications of CSPs - Graph Coloring}
    \begin{itemize}
        \item \textbf{Graph Coloring:}
        \begin{itemize}
            \item \textbf{Description:} Assigning colors to nodes in a graph such that adjacent nodes receive different colors.
            \item \textbf{Example:} 
                Frequency assignment in mobile networks, where base stations are assigned different frequencies to reduce interference.
            \item \textbf{Illustration:}
            \begin{itemize}
                \item Variables: Nodes of the graph
                \item Domains: Colors (R, G, B)
                \item Constraints: Adjacent nodes cannot share the same color.
            \end{itemize}
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Importance and Algorithms of CSPs}
    \begin{itemize}
        \item \textbf{Importance of CSPs:}
        \begin{itemize}
            \item Provide a framework to describe and solve challenges in various fields such as operations research, artificial intelligence, and logistics.
            \item Enable efficient solutions to problems previously deemed intractable with computational tools and algorithms.
        \end{itemize}
        \item \textbf{Key Points to Remember:}
        \begin{itemize}
            \item CSPs model diverse problems and are central to real-world applications.
            \item The effectiveness of CSPs relies on clearly defined constraints and accurate modeling of relationships between variables.
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Challenges in Search Algorithms}
    \begin{block}{Learning Objectives}
        \begin{itemize}
            \item Understand the common challenges in search algorithms.
            \item Recognize the limitations and implications of these challenges on problem-solving.
            \item Explore examples that illustrate each challenge.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{1. Introduction to Search Algorithms}
    Search algorithms are foundational techniques in artificial intelligence, used to navigate through problem spaces to find solutions. 
    While powerful, they encounter various challenges that can significantly impact their efficiency and effectiveness.
\end{frame}

\begin{frame}[fragile]
    \frametitle{2. Common Challenges in Search Algorithms}
    \begin{itemize}
        \item \textbf{A. Exponential Search Space}
        \begin{itemize}
            \item \textbf{Explanation:} Many problems, particularly in combinatorial spaces (e.g., chess), lead to exponentially growing search spaces.
            \item \textbf{Example:} In chess, each player typically has about 20 possible moves, creating millions of game states.
            \item \textbf{Implication:} Exhaustive search becomes infeasible in reasonable time.
        \end{itemize}
        
        \item \textbf{B. Local Optima}
        \begin{itemize}
            \item \textbf{Explanation:} Algorithms may converge on a locally optimal solution that is not globally optimal.
            \item \textbf{Example:} Optimization problems can yield a solution better than immediate neighbors but not the best overall.
            \item \textbf{Visual:} Imagine a hiker stuck on a hill (local optimum) while the tallest mountain (global optimum) is beyond the valley.
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{2. Common Challenges in Search Algorithms (Cont.)}
    \begin{itemize}
        \item \textbf{C. Uncertainty and Incomplete Data}
        \begin{itemize}
            \item \textbf{Explanation:} Many real-world problems involve uncertainty or incomplete information, complicating the search.
            \item \textbf{Example:} In medical diagnosis, symptoms may not correlate directly with diseases due to missing patient history.
            \item \textbf{Implication:} Algorithms must incorporate probabilistic reasoning to handle uncertainty.
        \end{itemize}
        
        \item \textbf{D. Time Complexity and Efficiency}
        \begin{itemize}
            \item \textbf{Explanation:} Significant time complexity can hinder performance on large-scale problems.
            \item \textbf{Example:} Breadth-First Search (BFS) has a time complexity of \(O(b^d)\).
            \item \textbf{Implication:} Increased problem size may lead to prohibitive computational resource requirements.
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{2. Common Challenges in Search Algorithms (Cont.)}
    \begin{itemize}
        \item \textbf{E. Memory Limitations}
        \begin{itemize}
            \item \textbf{Explanation:} Some search algorithms require significant memory to store explored nodes.
            \item \textbf{Example:} Depth-First Search (DFS) may face stack overflow due to deep recursions.
            \item \textbf{Implication:} Alternative strategies, such as iterative deepening, may be necessary for effective memory management.
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{3. Key Points to Emphasize}
    \begin{itemize}
        \item \textbf{Understand Search Spaces:} Recognizing their structure guides algorithm choice.
        \item \textbf{Trade-offs:} There is often a trade-off between optimality and efficiency; heuristic methods may provide quicker solutions.
        \item \textbf{Adapt to Real-World Constraints:} Be mindful of uncertainties and consider incorporating probabilistic methods in search strategies.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{4. Conclusion}
    Search algorithms play a vital role in solving complex problems. Recognizing their limitations encourages the development of more robust algorithms and adaptation to practical applications.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Future Directions in Search Algorithms}
    \begin{block}{Overview}
        Search algorithms and Constraint Satisfaction Problems (CSPs) are key areas in artificial intelligence and optimization, vital for enhancing computational efficiency and solution quality.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Future Directions - Hybrid Approaches}
    \begin{itemize}
        \item \textbf{Hybrid Approaches}
            \begin{itemize}
                \item Combining different search techniques (e.g., local and global search).
                \item Example: Using graph search algorithms with heuristics for route optimization.
            \end{itemize}
        \item \textit{Illustration:} Integration of A* search and Genetic Algorithms.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Future Directions - Machine Learning Integration}
    \begin{itemize}
        \item \textbf{Machine Learning Integration}
            \begin{itemize}
                \item Utilizing machine learning to predict promising paths in search algorithms.
                \item Example: Deep Q-Networks (DQN) for decision-making enhancement.
            \end{itemize}
        \item \textit{Code Snippet:}
        \begin{lstlisting}
        # Pseudocode for integrating RL with a Search Algorithm
        while not goal_reached:
            state = get_current_state()
            action = agent.select_action(state)
            perform_action(action)
            reward = evaluate_state()
            agent.update(state, action, reward)
        \end{lstlisting}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Future Directions - Increased Parallelism}
    \begin{itemize}
        \item \textbf{Increased Parallelism}
            \begin{itemize}
                \item Leveraging multi-core and distributed computing.
                \item Example: Parallel implementation of breadth-first search (BFS).
            \end{itemize}
        \item \textit{Key Points:} Improved efficiency and reduced execution time.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Future Directions - Probabilistic Methods}
    \begin{itemize}
        \item \textbf{Probabilistic and Stochastic Methods}
            \begin{itemize}
                \item Using randomness to escape local minima.
                \item Example: Simulated Annealing and Particle Swarm Optimization.
            \end{itemize}
        \item \textit{Formula for Simulated Annealing:}
        \begin{equation}
            P(E') = e^{-\frac{E' - E}{T}}
        \end{equation}
        Where \(E'\) is the energy of the new state, \(E\) is the current state's energy, and \(T\) is the temperature parameter.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Future Directions - Real-World Applications}
    \begin{itemize}
        \item \textbf{Focusing on Real-world Applications}
            \begin{itemize}
                \item Adapting search algorithms for robotics, autonomous vehicles, and network optimization.
                \item Example: CSPs for scheduling and resource allocation in smart grids.
            \end{itemize}
    \end{itemize}

    \begin{block}{Key Points to Emphasize}
        \begin{itemize}
            \item Transition to hybrid, machine learning-enhanced algorithms.
            \item Importance of parallel computing for efficiency.
            \item Fundamental understanding of each approach is essential.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Summary of Key Takeaways - Search Algorithms}
    \begin{block}{Key Concepts}
        \begin{enumerate}
            \item \textbf{Search Algorithms}
            \begin{itemize}
                \item \textbf{Uninformed Search}
                \begin{itemize}
                    \item \textbf{Breadth-First Search (BFS)}: Explores nodes level by level. 
                    \begin{itemize}
                        \item \textit{Use Case}: Finding the shortest path in an unweighted graph.
                    \end{itemize}
                    \item \textbf{Depth-First Search (DFS)}: Goes as deep as possible before backtracking.
                    \begin{itemize}
                        \item \textit{Use Case}: Pathfinding in puzzles or games.
                    \end{itemize}
                \end{itemize}
                
                \item \textbf{Informed Search}
                \begin{itemize}
                    \item \textbf{A* Algorithm}: Combines cost to reach a node with heuristic estimate.
                    \begin{itemize}
                        \item \textit{Formula}: $f(n) = g(n) + h(n)$
                        \item \textit{Use Case}: Navigation systems and game AI.
                    \end{itemize}
                \end{itemize}
            \end{enumerate}
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Summary of Key Takeaways - Constraint Satisfaction Problems (CSPs)}
    \begin{block}{Key Concepts}
        \begin{itemize}
            \item \textbf{Constraint Satisfaction Problems (CSPs)}
            \begin{itemize}
                \item Finding values for variables that satisfy specific constraints.
                \item \textbf{Components of CSP}:
                \begin{itemize}
                    \item \textbf{Variables}: Elements needing values.
                    \item \textbf{Domains}: Possible values for each variable.
                    \item \textbf{Constraints}: Rules restricting value assignments.
                \end{itemize}
                \item \textbf{Example}: Sudoku, where each cell must follow rules regarding number placement without repetition.
            \end{itemize}
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Points and Visualizations}
    \begin{block}{Key Points to Emphasize}
        \begin{itemize}
            \item \textbf{Trade-offs}: Understanding time complexity vs. memory usage is crucial in algorithm selection.
            \item \textbf{Heuristics}: The effectiveness of informed search algorithms relies on chosen heuristics.
            \item \textbf{Backtracking}: Techniques like backtracking explore solutions while pruning invalid paths in CSPs.
        \end{itemize}
    \end{block}
    
    \begin{block}{Visual Illustrations}
        \begin{itemize}
            \item A* Algorithm Visualization: Diagram illustrating $g(n)$, $h(n)$, and resulting $f(n)$ values along the path to the goal.
            \item CSP Example: Visual representation of a Sudoku board showing constraints and variable assignments.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Q\&A and Discussion}
    \begin{block}{Objective}
        To clarify concepts related to search algorithms and constraint satisfaction problems (CSPs) discussed in Chapters 3-4, enabling students to deepen their understanding through interactive dialogue.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Concepts to Discuss}
    \begin{itemize}
        \item \textbf{Search Algorithms}
            \begin{itemize}
                \item Definition: Procedures for exploring and navigating through a search space to find solutions.
                \item Types:
                    \begin{itemize}
                        \item \textbf{Uninformed Search}: BFS, DFS (no additional information).
                        \item \textbf{Informed Search}: A* algorithm (uses heuristics).
                    \end{itemize}
                \item \textbf{Example Discussion Point}: Why might A* be preferred over DFS in certain scenarios?
            \end{itemize}

        \item \textbf{Constraint Satisfaction Problems (CSPs)}
            \begin{itemize}
                \item Definition: Problems defined by a set of variables, their possible values, and constraints.
                \item Components:
                    \begin{itemize}
                        \item Variables: Entities for which we want to find values.
                        \item Domains: Possible values for each variable.
                        \item Constraints: Rules specifying allowable combinations.
                    \end{itemize}
                \item \textbf{Example Discussion Point}: How do Sudoku rules translate into constraints?
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Facilitating Discussion}
    \begin{itemize}
        \item \textbf{Key Questions:}
            \begin{itemize}
                \item How do different search strategies affect efficiency?
                \item Real-world applications of CSPs (logistics, scheduling)?
                \item When might heuristics lead to suboptimal solutions in A*?
            \end{itemize}

        \item \textbf{Essential Concepts and Examples:}
            \begin{equation}
                f(n) = g(n) + h(n)
            \end{equation}
            where \( f(n) \) = estimated cost, \( g(n) \) = cost to reach node, \( h(n) \) = estimated cost to goal.

            \begin{lstlisting}[language=Python]
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
    return visited
            \end{lstlisting}
    \end{itemize}
\end{frame}


\end{document}