\documentclass[aspectratio=169]{beamer}

% Theme and Color Setup
\usetheme{Madrid}
\usecolortheme{whale}
\useinnertheme{rectangles}
\useoutertheme{miniframes}

% Additional Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}
\usetikzlibrary{positioning}
\usepackage{hyperref}

% Custom Colors
\definecolor{myblue}{RGB}{31, 73, 125}
\definecolor{mygray}{RGB}{100, 100, 100}
\definecolor{mygreen}{RGB}{0, 128, 0}
\definecolor{myorange}{RGB}{230, 126, 34}
\definecolor{mycodebackground}{RGB}{245, 245, 245}

% Set Theme Colors
\setbeamercolor{structure}{fg=myblue}
\setbeamercolor{frametitle}{fg=white, bg=myblue}
\setbeamercolor{title}{fg=myblue}
\setbeamercolor{section in toc}{fg=myblue}
\setbeamercolor{item projected}{fg=white, bg=myblue}
\setbeamercolor{block title}{bg=myblue!20, fg=myblue}
\setbeamercolor{block body}{bg=myblue!10}
\setbeamercolor{alerted text}{fg=myorange}

% Set Fonts
\setbeamerfont{title}{size=\Large, series=\bfseries}
\setbeamerfont{frametitle}{size=\large, series=\bfseries}
\setbeamerfont{caption}{size=\small}
\setbeamerfont{footnote}{size=\tiny}

% Code Listing Style
\lstdefinestyle{customcode}{
  backgroundcolor=\color{mycodebackground},
  basicstyle=\footnotesize\ttfamily,
  breakatwhitespace=false,
  breaklines=true,
  commentstyle=\color{mygreen}\itshape,
  keywordstyle=\color{blue}\bfseries,
  stringstyle=\color{myorange},
  numbers=left,
  numbersep=8pt,
  numberstyle=\tiny\color{mygray},
  frame=single,
  framesep=5pt,
  rulecolor=\color{mygray},
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2,
  captionpos=b
}
\lstset{style=customcode}

% Custom Commands
\newcommand{\hilight}[1]{\colorbox{myorange!30}{#1}}
\newcommand{\source}[1]{\vspace{0.2cm}\hfill{\tiny\textcolor{mygray}{Source: #1}}}
\newcommand{\concept}[1]{\textcolor{myblue}{\textbf{#1}}}
\newcommand{\separator}{\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}}

% Footer and Navigation Setup
\setbeamertemplate{footline}{
  \leavevmode%
  \hbox{%
  \begin{beamercolorbox}[wd=.3\paperwidth,ht=2.25ex,dp=1ex,center]{author in head/foot}%
    \usebeamerfont{author in head/foot}\insertshortauthor
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.25ex,dp=1ex,center]{title in head/foot}%
    \usebeamerfont{title in head/foot}\insertshorttitle
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.2\paperwidth,ht=2.25ex,dp=1ex,center]{date in head/foot}%
    \usebeamerfont{date in head/foot}
    \insertframenumber{} / \inserttotalframenumber
  \end{beamercolorbox}}%
  \vskip0pt%
}

% Turn off navigation symbols
\setbeamertemplate{navigation symbols}{}

% Title Page Information
\title[Game Playing Algorithms]{Chapter 6: Game Playing Algorithms}
\author[J. Smith]{John Smith, Ph.D.}
\institute[University Name]{
  Department of Computer Science\\
  University Name\\
  Email: email@university.edu\\
  Website: www.university.edu
}
\date{\today}

% Document Start
\begin{document}

\frame{\titlepage}

\begin{frame}[fragile]
    \titlepage
\end{frame}

\begin{frame}[fragile]
    \frametitle{Overview of Game Playing Algorithms}
    \begin{itemize}
        \item Game-playing algorithms simulate human-like decision-making in structured environments.
        \item They assess potential moves and outcomes using mathematical models.
        \item Significance extends beyond gaming into real-world applications.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Concepts: Definitions and Importance}
    \begin{enumerate}
        \item \textbf{Definition of Game Playing Algorithms}:
            \begin{itemize}
                \item Algorithms for decision-making in games or competitive scenarios.
                \item Evaluate possible moves based on game rules and strategies.
            \end{itemize}
        \item \textbf{Importance in AI}:
            \begin{itemize}
                \item Exemplifies decision-making, strategy formation, and adaptive learning.
                \item Pivotal to AI development and evolution.
            \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Real-World Applications}
    \begin{itemize}
        \item \textbf{Chess Engines} (e.g., Stockfish, AlphaZero):
            \begin{itemize}
                \item Evaluate millions of positions per second using Minimax and Alpha-Beta pruning.
                \item Calculate optimal moves by anticipating opponent responses.
            \end{itemize}
        \item \textbf{Game Theory in Economics}:
            \begin{itemize}
                \item Models economic strategies for competitive pricing and market entry.
                \item Predict competitor reactions in pricing wars.
            \end{itemize}
        \item \textbf{Robotics and Autonomous Vehicles}:
            \begin{itemize}
                \item Assist in pathfinding and obstacle avoidance for optimal navigation.
                \item Anticipate human driver behavior in complex environments.
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Fundamental Algorithms: Minimax}
    \begin{block}{Minimax Algorithm}
        \begin{itemize}
            \item Adversarial search for zero-sum games.
            \item Explores potential moves to minimize losses in worst-case scenarios.
        \end{itemize}
        \begin{equation}
        \text{Minimax}(node) = 
        \begin{cases} 
        \text{value of node} & \text{if node is terminal} \\ 
        \max(\text{Minimax}(\text{child node})) & \text{if it’s the maximizing player's turn} \\ 
        \min(\text{Minimax}(\text{child node})) & \text{if it’s the minimizing player's turn} 
        \end{cases}
        \end{equation}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Fundamental Algorithms: Alpha-Beta Pruning}
    \begin{block}{Alpha-Beta Pruning}
        \begin{itemize}
            \item Optimization technique for Minimax.
            \item Eliminates branches that do not impact the final decision.
        \end{itemize}
        \begin{itemize}
            \item \textbf{Illustration}:
                \begin{enumerate}
                    \item In Minimax, all branches are explored.
                    \item With Alpha-Beta pruning, unnecessary branches are not evaluated.
                \end{enumerate}
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Takeaways and References}
    \begin{itemize}
        \item Game playing algorithms are a crucial intersection of strategy, computation, and AI.
        \item Their adaptability allows application across diverse fields beyond gaming.
        \item Understanding these algorithms provides insights into AI decision-making processes.
    \end{itemize}
    
    \textbf{References for Further Reading:}
    \begin{itemize}
        \item Russell, S., \& Norvig, P. (2016). \textit{Artificial Intelligence: A Modern Approach}.
        \item Uhrmacher, A. M., \& Wilensky, U. (1998). "Game Theory and Multi-Agent-Based Simulation." In \textit{Proceedings of the First Workshop on Agent-Based Simulation.}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Importance of Game Theory in AI - Overview}
    \begin{block}{Understanding Game Theory}
        Game Theory is a mathematical framework used to model and analyze competitive situations involving multiple decision-makers (players). It provides the tools necessary for AI to make strategic decisions in structured interactions.
    \end{block}
\end{frame}

\begin{frame}[fragile]{Importance of Game Theory in AI - Key Concepts}
    \begin{itemize}
        \item \textbf{Players}: The entities making decisions in a game (e.g., humans, AI, organizations).
        \item \textbf{Strategies}: The plan of action a player can take, which may vary in complexity.
        \item \textbf{Payoffs}: Outcomes from strategies, often represented numerically to reflect utility or reward.
        \item \textbf{Nash Equilibrium}: A state where no player can benefit by changing their strategy while others remain constant, indicating stability in interactions.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Importance of Game Theory in AI - Applications}
    \begin{enumerate}
        \item \textbf{Competitive Environments}: AI must anticipate and respond to competing agents.
            \begin{itemize}
                \item Example: Algorithms in automated trading predict competitor strategies to maximize profits.
            \end{itemize}
        
        \item \textbf{Multi-Agent Systems}: Frameworks for cooperation and competition between multiple agents (e.g., robotics, negotiations).
            \begin{itemize}
                \item Example: Autonomous vehicles optimizing paths based on other drivers' decisions.
            \end{itemize}
        
        \item \textbf{Strategic Decision-Making}: AI employs game-theoretic principles to make informed decisions considering others' potential actions.
            \begin{itemize}
                \item Example: Chess AI evaluates moves based on opponent's potential responses.
            \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]{Importance of Game Theory in AI - Example: The Prisoner's Dilemma}
    Consider two criminals arrested and interrogated separately. Each can either confess (defect) or remain silent (cooperate). The outcomes in a payoff matrix are:

    \[
    \begin{array}{|c|c|c|}
        \hline
        & \text{Player B Confesses} & \text{Player B Silent} \\
        \hline
        \text{Player A Confesses} & (-5, -5) & (0, -10) \\
        \hline
        \text{Player A Silent} & (-10, 0) & (-1, -1) \\
        \hline
    \end{array}
    \]

    \textbf{Nash Equilibrium:} Occurs when both players choose to confess. This reflects a situation where neither can improve their outcome by changing their strategy alone.
\end{frame}

\begin{frame}[fragile]{Conclusion - Importance of Game Theory in AI}
    Understanding game theory principles is crucial for developing AI systems capable of strategic thought and effective decision-making in competitive and uncertain environments.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Minimax Algorithm Overview - Part 1}
    \begin{block}{What is the Minimax Algorithm?}
        The minimax algorithm is a decision-making tool used primarily in two-player, zero-sum games (games where one player's gain is equivalent to the other's loss). Its purpose is to determine the best move for a player by minimizing the possible loss in the worst-case scenario.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Minimax Algorithm Overview - Part 2}
    \begin{block}{How Does the Minimax Algorithm Work?}
        \begin{enumerate}
            \item \textbf{Game Tree Representation}: The algorithm visualizes all possible moves in a game as a tree structure.
            \item \textbf{Two Players}:
                \begin{itemize}
                    \item \textbf{Maximizer}: Aims to maximize their score.
                    \item \textbf{Minimizer}: Aims to minimize the score of the maximizer.
                \end{itemize}
            \item \textbf{Recursive Evaluation}:
                \begin{itemize}
                    \item Maximizer's turn: Node value is the highest of its children.
                    \item Minimizer's turn: Node value is the lowest of its children.
                \end{itemize}
            \item \textbf{Backtracking}: Determines the best move for the maximizer based on calculated scores.
        \end{enumerate}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Minimax Algorithm Overview - Part 3}
    \begin{block}{Example: Tic-Tac-Toe}
        Consider a simplified Tic-Tac-Toe scenario:
        \begin{itemize}
            \item If it’s Player X's turn (the maximizer):
                \begin{itemize}
                    \item Move A leads to a game state with a value of +1 (X wins).
                    \item Move B leads to a game state with a value of -1 (O wins).
                \end{itemize}
        \end{itemize}
        The minimax algorithm will prioritize Move A, leading to +1.
    \end{block}
    
    \begin{block}{Key Points to Emphasize}
        \begin{itemize}
            \item \textbf{Zero-Sum}: Useful in zero-sum games.
            \item \textbf{Optimal Play}: Assumes both players play optimally.
            \item \textbf{Complexity}: Can be computationally expensive; enhancements like alpha-beta pruning can improve efficiency.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Minimax Algorithm Overview - Pseudocode}
    \begin{block}{Pseudocode for Minimax Algorithm}
    \begin{lstlisting}[language=Python]
function minimax(node, depth, isMaximizing):
    if node is a terminal state or depth == 0:
        return evaluate(node)
    
    if isMaximizing:
        maxEval = -infinity
        for each child in node.children:
            eval = minimax(child, depth - 1, false)
            maxEval = max(maxEval, eval)
        return maxEval
    else:
        minEval = +infinity
        for each child in node.children:
            eval = minimax(child, depth - 1, true)
            minEval = min(minEval, eval)
        return minEval
    \end{lstlisting}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Minimax Algorithm Steps - Overview}
    \begin{block}{Overview}
        The Minimax algorithm is a decision-making tool used primarily in two-player, zero-sum games where one player's gain is the other player's loss. Understanding the implementation steps is crucial for effectively applying this algorithm.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Minimax Algorithm Steps - Implementation}
    \begin{enumerate}
        \item \textbf{Game State Representation:}
        \begin{itemize}
            \item Define a structure to represent the game state (e.g., board, player positions).
            \item Example: In Tic-Tac-Toe, the board can be represented as a 3x3 matrix.
        \end{itemize}
        
        \item \textbf{Terminal States Identification:}
        \begin{itemize}
            \item Determine conditions for winning, losing, or drawing.
            \item Example: A game state is terminal if one player has three symbols in a row or the board is full.
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Minimax Algorithm Steps - Function and Evaluation}
    \begin{enumerate}
        \setcounter{enumi}{2}
        \item \textbf{Minimax Function:}
        \begin{lstlisting}[language=Python]
        function minimax(state, depth, isMaximizingPlayer):
            if state is terminal:
                return score(state)
            if isMaximizingPlayer:
                bestScore = -∞
                for each possible move:
                    score = minimax(newState, depth + 1, false)
                    bestScore = max(bestScore, score)
                return bestScore
            else:
                bestScore = ∞
                for each possible move:
                    score = minimax(newState, depth + 1, true)
                    bestScore = min(bestScore, score)
                return bestScore
        \end{lstlisting}
        
        \item \textbf{Evaluate the Game State:}
        \begin{itemize}
            \item Assign a score to each terminal state.
            \item Example scoring:
            \begin{itemize}
                \item Win: +10
                \item Loss: -10
                \item Draw: 0
            \end{itemize}
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Minimax Algorithm Steps - Decision Making}
    \begin{enumerate}
        \setcounter{enumi}{4}
        \item \textbf{Generate Possible Moves:}
        \begin{itemize}
            \item For the current player, generate all legal moves from the current game state and call the Minimax function recursively.
        \end{itemize}

        \item \textbf{Decision Making:}
        \begin{itemize}
            \item If it’s the maximizing player's turn, choose the move leading to the highest score.
            \item If it’s the minimizing player's turn, choose the move leading to the lowest score.
        \end{itemize}
        
        \item \textbf{Playing the Game:}
        \begin{itemize}
            \item Use the Minimax algorithm to select the optimal move in an ongoing game.
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Minimax Algorithm - Key Points and Conclusion}
    \begin{block}{Key Points to Emphasize}
        \begin{itemize}
            \item Minimax operates via a recursive exploration of potential game outcomes.
            \item It effectively predicts possible future scenarios, ensuring that the best decision is made at every turn.
            \item Complexity arises from the depth of recursion and branching factor of possible moves.
        \end{itemize}
    \end{block}
    
    \begin{block}{Conclusion}
        Understanding and implementing the Minimax algorithm is fundamental for developing AI in strategic games. The steps outlined provide a robust framework for decision-making in competitive environments.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Game Tree Representation - Introduction}
    \begin{block}{Introduction to Game Trees}
        Game trees are a foundational concept in artificial intelligence, especially for two-player games. They provide a structured way to represent the possible moves and outcomes of a game.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Game Tree Representation - Structure}
    \begin{block}{Structure of Game Trees}
        \begin{itemize}
            \item \textbf{Nodes}: Each node represents a game state, which includes information about the positions of all game elements (e.g., player pieces on a board).
            \item \textbf{Edges}: The connections between nodes represent valid moves made by players.
            \item \textbf{Root Node}: The starting state of the game from which all possible moves will branch out.
            \item \textbf{Leaf Nodes}: Terminal nodes that represent final outcomes of the game, such as win, loss, or draw.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Game Tree Representation - Example}
    \begin{block}{Example: Tic-Tac-Toe}
        \begin{enumerate}
            \item \textbf{Root Node (Initial State)}:
                \begin{itemize}
                    \item The board is empty.
                    \item Players can place their marks on any of the 9 squares.
                \end{itemize}
            \item \textbf{First Level (Player 1's Moves)}:
                \begin{itemize}
                    \item Each potential move creates a new node. E.g., placing 'X' in the center.
                \end{itemize}
            \item \textbf{Second Level (Player 2's Moves)}:
                \begin{itemize}
                    \item Player 2 makes a decision based on Player 1's moves, leading to further branching.
                \end{itemize}
            \item \textbf{Terminal Nodes}:
                \begin{itemize}
                    \item The tree expands until all possible outcomes are evaluated.
                \end{itemize}
        \end{enumerate}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Game Tree Representation - Minimax Algorithm}
    \begin{block}{Using Game Trees with Minimax Algorithm}
        The \textbf{Minimax Algorithm} traverses the game tree to find the best move:
        \begin{itemize}
            \item \textbf{Max nodes}: Seek to maximize the score (Player 1).
            \item \textbf{Min nodes}: Aim to minimize the score (Player 2).
        \end{itemize}
        This process continues until all possible outcomes are explored, allowing backtracking to find the optimal solution.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Game Tree Representation - Code Example}
    \begin{block}{Code Snippet Example (Pseudocode)}
        \begin{lstlisting}[language=Python]
def minimax(node, depth, maximizingPlayer):
    if depth == 0 or is_terminal(node):
        return evaluate_node(node)

    if maximizingPlayer:
        maxEval = float('-inf')
        for child in get_children(node):
            eval = minimax(child, depth - 1, False)
            maxEval = max(maxEval, eval)
        return maxEval
    else:
        minEval = float('inf')
        for child in get_children(node):
            eval = minimax(child, depth - 1, True)
            minEval = min(minEval, eval)
        return minEval
        \end{lstlisting}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Game Tree Representation - Conclusion}
    \begin{block}{Conclusion}
        Understanding game tree representation is crucial for grasping how the minimax algorithm operates. Visualizing structures of potential game moves enhances comprehension of decision-making in AI for gaming.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Minimax Example - Overview}
    \begin{block}{Overview of Minimax Algorithm}
        The Minimax algorithm is a decision-making tool used in two-player games to minimize possible loss for a worst-case scenario. The algorithm alternates between maximizing and minimizing nodes in the game tree.
    \end{block}
    
    \begin{block}{Key Points}
        \begin{itemize}
            \item Systematically evaluates potential moves by generating a game tree.
            \item Each node corresponds to a possible state of the game and its score value.
            \item Assumes both players play optimally: maximizer aims for highest score, minimizer for lowest score.
            \item Complexity grows exponentially with the increase in possible moves.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Minimax Example - Game Scenario}
    \begin{block}{Example Scenario: Tic-Tac-Toe}
        Let's consider Tic-Tac-Toe with 'X' as our player (maximizer) and 'O' as the opponent (minimizer).
    \end{block}

    \begin{block}{Initial State}
        The board is as follows:
        \begin{lstlisting}
        X | O | X
        ---------
        O | X |
        ---------
          | O |
        \end{lstlisting}
    \end{block}

    \begin{block}{Possible Moves}
        The X player can move to the empty space at (2, 2):
        \begin{lstlisting}
        X | O | X
        ---------
        O | X | X
        ---------
          | O |
        \end{lstlisting}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Minimax Example - Game Tree & Conclusion}
    \begin{block}{Game Tree Construction}
        The minimax algorithm builds a tree of possible outcomes:
        \begin{lstlisting}
              X
             / \
            O   O
           /     \
          +1      0
        \end{lstlisting}
    \end{block}

    \begin{block}{Backpropagation of Scores}
        \begin{itemize}
            \item If X wins, score is +1.
            \item If draw, score is 0.
            \item X chooses the move that maximizes the score.
        \end{itemize}
    \end{block}
    
    \begin{block}{Conclusion}
        Using the minimax algorithm in this example highlights intelligent decision-making to facilitate winning strategies. Systematic exploration helps players predict and counter opponents effectively.
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Limitations of Minimax}
    \begin{block}{Overview}
        The **Minimax Algorithm** is essential for decision-making in two-player games but faces significant limitations, especially in complex scenarios. We will discuss the key challenges related to computational complexity and game tree size.
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Key Limitations of Minimax}
    \begin{enumerate}
        \item \textbf{Exponential Growth of Game Trees}
        \begin{itemize}
            \item Game trees can grow exponentially with many possible moves.
            \item Example: In chess, around 20 moves per position leads to $20^{10}$ nodes (over 100 trillion).
        \end{itemize}
        
        \item \textbf{Time Complexity}
        \begin{itemize}
            \item Basic time complexity is $O(b^d)$, where:
            \begin{itemize}
                \item $b$: branching factor (average moves)
                \item $d$: depth of the game tree
            \end{itemize}
            \item As $b$ and $d$ increase, computation time is impractical.
        \end{itemize}
        
        \item \textbf{Memory Limitations}
        \begin{itemize}
            \item High-depth evaluations require significant memory for storing the entire game tree.
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}
    \frametitle{Further Limitations}
    \begin{enumerate}
        \setcounter{enumi}{3}
        \item \textbf{Static Evaluation Function Limitations}
        \begin{itemize}
            \item Minimax relies on heuristic evaluations. Inaccurate evaluations can lead to poor decisions.
            \item Example: In chess, simple evaluations might overlook long-term strategic advantages.
        \end{itemize}
        
        \item \textbf{Lack of Real-Time Decision Making}
        \begin{itemize}
            \item Lengthy computations can delay responses in real-time games, making minimax unsuitable for these situations.
        \end{itemize}
        
        \item \textbf{Conclusion}
        \begin{itemize}
            \item Minimax has theoretical strengths, but its limitations in complex scenarios lead to exploring alternatives like **Alpha-Beta Pruning** to improve efficiency.
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Example Code Snippet}
    Here is a simplified implementation of the Minimax algorithm:
    \begin{lstlisting}[language=Python]
def minimax(node, depth, maximizingPlayer):
    if depth == 0 or node.is_terminal():
        return evaluate(node)

    if maximizingPlayer:
        maxEval = float('-inf')
        for child in node.children():
            eval = minimax(child, depth - 1, False)
            maxEval = max(maxEval, eval)
        return maxEval
    else:
        minEval = float('inf')
        for child in node.children():
            eval = minimax(child, depth - 1, True)
            minEval = min(minEval, eval)
        return minEval
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Alpha-Beta Pruning Overview}
    \begin{block}{Introduction}
        Alpha-beta pruning is an optimization technique used to enhance the efficiency of the minimax algorithm in decision-making scenarios.
        Its primary goal is to reduce the number of nodes evaluated in the game tree, decreasing computational time while maintaining decision-making quality.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Purpose of Alpha-Beta Pruning}
    \begin{itemize}
        \item \textbf{Efficiency Improvement}: Reduces exponential time complexity by ignoring non-influential branches in the decision tree.
        \item \textbf{Optimal Play}: Maintains optimal strategies for both players despite fewer nodes being evaluated.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Concepts}
    \begin{enumerate}
        \item \textbf{Game Tree}: Represents all possible moves in a game; each node corresponds to a game state.
        \item \textbf{Alpha Value ($\alpha$)}: Best score the maximizing player can guarantee at that level or above.
        \item \textbf{Beta Value ($\beta$)}: Best score the minimizing player can guarantee at that level or below.
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Pruning Mechanism}
    \begin{itemize}
        \item Traverses the game tree, comparing $\alpha$ and $\beta$ values:
        \begin{itemize}
            \item At maximizing nodes, if a child's value $\geq \beta$, prune this node.
            \item At minimizing nodes, if a child's value $\leq \alpha$, prune this node.
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Example: Game Tree Evaluation}
    \begin{block}{Scenario}
        \begin{itemize}
            \item Maximizing player (Max) evaluating node A with a value of 4.
            \item Minimizing player (Min) has a child node with a value of 5.
            \item During Min's evaluation, a value of 3 is found (3 < 5), updating $\beta$ to 3.
            \item Max evaluates the next child node and finds 4 again, leading to pruning since 4 $\geq$ $\beta$ (3).
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Points to Emphasize}
    \begin{itemize}
        \item Alpha-beta pruning significantly reduces the search space, leading to faster decision-making times.
        \item Efficiency depends on the order of node evaluations; better ordering yields more pruning.
        \item The process does not compromise the minimax property of making optimal moves.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Conclusion}
    Alpha-beta pruning is a critical enhancement to the minimax algorithm, enabling practical application in real-time strategy games and complex decision-making scenarios by reducing unnecessary computations while ensuring optimal strategies.
\end{frame}

\begin{frame}[fragile]
    \frametitle{How Alpha-Beta Pruning Works - Introduction}
    \begin{block}{Introduction to Alpha-Beta Pruning}
        Alpha-Beta Pruning is an optimization technique for the minimax algorithm used in two-player games. Its primary objective is to reduce the number of nodes evaluated in the game tree.
    \end{block}
    \begin{itemize}
        \item Improves efficiency of search algorithm
        \item Final result remains unaffected
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{How Alpha-Beta Pruning Works - Mechanism}
    \begin{block}{Definitions}
        \begin{itemize}
            \item Alpha ($\alpha$): Best score for maximizing player; initially set to $-\infty$.
            \item Beta ($\beta$): Best score for minimizing player; initially set to $+\infty$.
        \end{itemize}
    \end{block}
    
    \begin{block}{Process}
        \begin{itemize}
            \item If $\alpha \geq \beta$, prune the branch.
            \item Examine nodes in depth-first manner for early pruning.
            \item Evaluating order affects pruning efficiency.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{How Alpha-Beta Pruning Works - Example}
    \begin{block}{Example Game Tree}
    \begin{lstlisting}
               (max)
           A        
          / \
       B      C
      / \    / \
    D   E  F   G
    \end{lstlisting}
    \end{block}
    
    \begin{itemize}
        \item Leaf node values:
            \begin{itemize}
                \item $D = 3$, $E = 5$, $F = 6$, $G = 9$
            \end{itemize}
        \item Step-by-step evaluation follows the defined process.
    \end{itemize}
    
    \begin{block}{Key Points}
        \begin{itemize}
            \item Pruning significantly reduces nodes evaluated.
            \item Order matters for efficiency.
            \item Does not alter optimal outcomes.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Alpha-Beta Pruning}
    \begin{block}{Introduction}
        Alpha-Beta Pruning is an optimization technique for the minimax algorithm used in decision-making processes for two-player games. 
        \begin{itemize}
            \item Eliminates branches in the game tree that do not affect the final decision.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Basic Concepts}
    \begin{itemize}
        \item \textbf{Alpha ($\alpha$):} The best value that the maximizer can guarantee at that level or above.
        \item \textbf{Beta ($\beta$):} The best value that the minimizer can guarantee at that level or above.
    \end{itemize}
    \begin{block}{Pruning Criteria}
        When $\alpha$ and $\beta$ are compared, branches that cannot yield a better outcome than the current best options can be pruned.
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Step-by-Step Example}
    \begin{block}{Game Tree Structure}
        \begin{center}
            \includegraphics[scale=0.5]{tree_structure.png} % Replace with actual image or diagram as needed
        \end{center}
    \end{block}

    \begin{enumerate}
        \item Initialization: Start at root node A, set $\alpha = -\infty$, $\beta = +\infty$.
        \item Traverse the tree (maximize at B, minimize at C).
        \begin{itemize}
            \item Evaluate D, E, F at B to update $\alpha$.
            \item Cutoff evaluation for C based on $\alpha$.
        \end{itemize}
        \item Decision: Node A compares $\alpha$ and $\beta$ to select the optimal path.
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Pseudocode for Alpha-Beta Pruning}
    \begin{lstlisting}[language=Python]
def alpha_beta(node, depth, α, β, maximizingPlayer):
    if depth == 0 or node is a terminal node:
        return evaluate(node)
    
    if maximizingPlayer:
        maxEval = -∞
        for child in node.children:
            eval = alpha_beta(child, depth - 1, α, β, False)
            maxEval = max(maxEval, eval)
            α = max(α, eval)
            if β <= α:
                break  # β cut-off
        return maxEval
    else:
        minEval = +∞
        for child in node.children:
            eval = alpha_beta(child, depth - 1, α, β, True)
            minEval = min(minEval, eval)
            β = min(β, eval)
            if β <= α:
                break  # α cut-off
        return minEval
    \end{lstlisting}
\end{frame}

\begin{frame}
    \frametitle{Conclusion}
    \begin{itemize}
        \item Alpha-Beta Pruning significantly enhances the performance of game-playing algorithms.
        \item Reduces the number of nodes evaluated while ensuring optimal outcomes.
        \item Essential for mastering game algorithms through practical understanding.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Benefits of Alpha-Beta Pruning}
    \begin{block}{Introduction}
        Alpha-beta pruning is an optimization technique for the minimax algorithm that significantly reduces the number of evaluated nodes in the game tree, enhancing computational efficiency.
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Key Benefits of Alpha-Beta Pruning}
    \begin{enumerate}
        \item \textbf{Reduces Search Space}
        \begin{itemize}
            \item \textbf{Concept}: Prunes irrelevant branches, decreasing evaluated nodes.
            \item \textbf{Impact}: Allows deeper search levels in the same time frame.
            \item \textbf{Example}: Achieves 4-5 levels deeper in the same time as standard minimax.
        \end{itemize}

        \item \textbf{Faster Decision Making}
        \begin{itemize}
            \item \textbf{Concept}: Leads to faster evaluations with fewer nodes processed.
            \item \textbf{Impact}: Enables quicker decisions in real-time gaming.
            \item \textbf{Example}: Reduces analysis time from seconds to milliseconds in vast search trees.
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}
    \frametitle{Key Benefits of Alpha-Beta Pruning (Continued)}
    \begin{enumerate}
        \setcounter{enumi}{2}
        \item \textbf{Maintains Minimax Accuracy}
        \begin{itemize}
            \item \textbf{Concept}: Does not compromise minimax integrity despite node reduction.
            \item \textbf{Impact}: Guarantees optimal outcomes, ensuring the AI plays its best.
            \item \textbf{Illustration}: Best move is still found without evaluating less favorable paths.
        \end{itemize}

        \item \textbf{Optimal Move Selection}
        \begin{itemize}
            \item \textbf{Concept}: Proper move ordering maximizes performance gains.
            \item \textbf{Impact}: Earlier pruning leads to increased efficiency.
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Code Snippet for Alpha-Beta Pruning}
    \begin{lstlisting}[language=Python]
def alpha_beta(node, depth, alpha, beta, maximizing_player):
    if depth == 0 or node is a terminal state:
        return heuristic_value(node)
    if maximizing_player:
        max_eval = float('-inf')
        for child in node.children:
            eval = alpha_beta(child, depth - 1, alpha, beta, False)
            max_eval = max(max_eval, eval)
            alpha = max(alpha, eval)
            if beta <= alpha:
                break  # Beta cut-off
        return max_eval
    else:
        min_eval = float('inf')
        for child in node.children:
            eval = alpha_beta(child, depth - 1, alpha, beta, True)
            min_eval = min(min_eval, eval)
            beta = min(beta, eval)
            if beta <= alpha:
                break  # Alpha cut-off
        return min_eval
    \end{lstlisting}
\end{frame}

\begin{frame}
    \frametitle{Summary of Performance Improvements}
    \begin{itemize}
        \item \textbf{Standard Minimax}: Evaluates approximately \(O(b^d)\) where \(b\) is branching factor and \(d\) is depth.
        \item \textbf{Alpha-Beta Pruning}: Improves time complexity to \(O(b^{d/2})\) with optimal move ordering.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Conclusion}
    Alpha-beta pruning presents significant performance boosts over conventional minimax by reducing evaluated nodes and speeding up decision-making while ensuring the accuracy and optimality of AI move selection. This optimization is crucial for advancing gaming AI.
\end{frame}

\begin{frame}
    \frametitle{Next Steps}
    Explore how to integrate the strengths of both minimax and alpha-beta pruning to develop more efficient AI solutions.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Combining Minimax and Alpha-Beta}
    \begin{block}{Introduction to Minimax and Alpha-Beta Pruning}
        \begin{itemize}
            \item **Minimax**: A strategy for decision-making in two-player games that minimizes the possible loss.
            \item **Alpha-Beta Pruning**: Optimizes Minimax by pruning branches of the game tree that won't affect the final decision.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{How They Work Together}
    \begin{enumerate}
        \item \textbf{Minimax Overview}:
        \begin{itemize}
            \item Objective: Choose optimal moves.
            \item MAX selects the highest score; MIN selects the lowest score.
        \end{itemize}
        
        \item \textbf{Alpha-Beta Pruning}:
        \begin{itemize}
            \item Introduces variables \(\alpha\) and \(\beta\) to optimize search.
            \item Prunes branches if the score is worse than current \(\alpha\) or \(\beta\).
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Implementation Steps and Example}
    \begin{block}{Implementation Steps}
        \begin{enumerate}
            \item Initialize Alpha and Beta:
            \begin{itemize}
                \item Start with \(\alpha = -\infty\), \(\beta = +\infty\).
            \end{itemize}
            \item Perform Depth-First Search with pruning conditions.
            \item Update \(\alpha\) and \(\beta\) during exploration:
            \begin{itemize}
                \item If at MAX, update \(\alpha\).
                \item If at MIN, update \(\beta\).
                \item Prune if \(\alpha \geq \beta\).
            \end{itemize}
        \end{enumerate}
    \end{block}
    
    \begin{block}{Example Scenario}
        \begin{itemize}
            \item Game Tree Structure:
            \begin{verbatim}
                MAX
              /    \
             A      B
            / \    / \
           C   D  E   F
            \end{verbatim}
            \item Initial values: \(\alpha = -\infty\), \(\beta = +\infty\).
            \item Evaluating subtrees results in pruning based on scores.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Code Snippet}
    \begin{block}{Code for Minimax with Alpha-Beta Pruning}
        \begin{lstlisting}[language=Python]
def minimax_alpha_beta(node, depth, alpha, beta, maximizing_player):
    if depth == 0 or is_terminal_node(node):
        return evaluate_node(node)

    if maximizing_player:
        max_eval = -float('inf')
        for child in get_children(node):
            eval = minimax_alpha_beta(child, depth-1, alpha, beta, False)
            max_eval = max(max_eval, eval)
            alpha = max(alpha, eval)
            if beta <= alpha:
                break
        return max_eval
    else:
        min_eval = float('inf')
        for child in get_children(node):
            eval = minimax_alpha_beta(child, depth-1, alpha, beta, True)
            min_eval = min(min_eval, eval)
            beta = min(beta, eval)
            if beta <= alpha:
                break
        return min_eval
        \end{lstlisting}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Conclusion}
    \begin{itemize}
        \item Combining Minimax with Alpha-Beta Pruning enhances AI efficiency.
        \item Enables exploration of larger game trees more quickly.
        \item Essential for competitive games like chess.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Practical Applications - Introduction}
    \begin{itemize}
        \item \textbf{Minimax Algorithm}: A decision-making algorithm widely used in two-player games. It aims to minimize the possible loss for a worst-case scenario (maximizing the minimum gain).
        \item \textbf{Alpha-Beta Pruning}: An optimization technique for the minimax algorithm that eliminates branches in the game tree that cannot influence the final decision, reducing computation time.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Practical Applications - Real-World Uses}
    \begin{enumerate}
        \item \textbf{Board Games}
            \begin{itemize}
                \item \textbf{Chess}: Used in chess engines to evaluate moves and determine optimal strategies.
                \item \textbf{Checkers}: The first game with a complete minimax-based program that plays perfectly.
            \end{itemize}
        \item \textbf{Video Games}
            \begin{itemize}
                \item \textbf{Turn-Based Strategy Games}: Games like "Civilization" and "XCOM" use these algorithms for enemy AI decisions.
                \item \textbf{Real-Time Games}: Adapted for decision-making in AI behavior (less common).
            \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Practical Applications - Key Benefits}
    \begin{itemize}
        \item \textbf{Efficiency}: Alpha-beta pruning significantly reduces the number of nodes evaluated by the minimax algorithm.
        \item \textbf{Real-Time Decision Making}: Enables AI to respond quickly and effectively to opponent moves.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Illustration of Alpha-Beta Pruning}
    \begin{block}{Example of Game Tree Pruning}
    \begin{verbatim}
            [A]
           /   \
         [B]   [C]
        /   \    \
      [D]   [E]  [F]
    \end{verbatim}
    \end{block}
    \textit{Assume [E] can be pruned since [C] has a guaranteed score lower than [B].}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Practical Applications - Conclusion}
    Minimax and alpha-beta pruning are foundational algorithms in game-playing AI, enabling the development of highly strategic and responsive gameplay. Their applications extend beyond gaming into simulations and economic models, showcasing their versatility and efficiency in real-world scenarios.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Practical Applications - Think About It}
    \begin{itemize}
        \item How might the ethical implications come into play with the use of these algorithms in competitive gaming?
        \item Can you think of other areas or fields where these algorithms could be beneficial?
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Ethical Considerations - Introduction}
    As artificial intelligence (AI) technologies, particularly those used in game playing, advance, it is crucial to examine the ethical implications surrounding their application. 
    The integration of AI into gaming not only reshapes player experiences but also poses significant societal impacts.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Ethical Considerations - Key Implications}
    \begin{enumerate}
        \item \textbf{Fairness and Transparency}
        \begin{itemize}
            \item \textit{Issue:} AI algorithms may create an uneven playing field by favoring players using AI tools over those who do not.
            \item \textit{Example:} One player uses AI to suggest moves, while another plays without assistance, raising fairness concerns in competitive settings.
        \end{itemize}
        
        \item \textbf{Addiction and Mental Health}
        \begin{itemize}
            \item \textit{Issue:} Game-playing AI can create engaging experiences that lead to prolonged play and potential addiction.
            \item \textit{Example:} AI-driven games that adapt to players' skill levels can foster addictive behaviors, resulting in negative mental health effects.
        \end{itemize}
        
        \item \textbf{Job Displacement}
        \begin{itemize}
            \item \textit{Issue:} The automation of game design and testing through AI could displace human jobs in the gaming industry.
            \item \textit{Example:} AI algorithms generating game content might reduce the need for human designers and testers.
        \end{itemize}
        
        \item \textbf{Data Privacy}
        \begin{itemize}
            \item \textit{Issue:} Many AI applications collect vast amounts of data, raising concerns about users' privacy.
            \item \textit{Example:} Multiplayer games that track player behavior may expose sensitive user data, highlighting a need for robust data protection measures.
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Ethical Considerations - Societal Impacts}
    \begin{itemize}
        \item \textbf{Normalization of AI:} As AI becomes integral to gaming, society may start to perceive it as a standard tool for problem-solving across various domains.
        
        \item \textbf{Shifts in Human Interaction:} The rise of AI in games can alter social interactions, with players forming bonds with AI characters instead of fellow humans.
    \end{itemize}
    
    \textbf{Conclusion:} While game-playing algorithms enhance gameplay, they introduce ethical dilemmas that must be addressed. Developers should consider the broader impacts of their technologies, fostering a responsible approach to AI in gaming.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Ethical Considerations - Key Takeaways}
    \begin{itemize}
        \item Fairness and addiction are major ethical concerns.
        \item AI can impact employment in the gaming sector.
        \item Robust privacy measures are necessary to protect user data.
        \item Society's relationship with AI is evolving, potentially reshaping social interactions.
    \end{itemize}
    
    \textbf{Preview Ahead:} Prepare for an interactive lab session where you will apply concepts learned to implement minimax and alpha-beta pruning algorithms in Python!
\end{frame}

\begin{frame}
    \frametitle{Interactive Lab Session}
    \begin{itemize}
        \item Overview of the upcoming lab session.
        \item Focus on two fundamental AI algorithms: Minimax and Alpha-Beta Pruning.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Overview of the Lab}
    \begin{block}{Key Concepts}
        \begin{itemize}
            \item **Minimax Algorithm**: Decision rule for minimizing potential loss.
            \item **Alpha-Beta Pruning**: Optimization of the Minimax algorithm.
        \end{itemize}
        \begin{itemize}
            \item Applicable to two-player turn-based games (e.g., chess, Tic-Tac-Toe).
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Minimax Algorithm}
    \begin{block}{Understanding Minimax}
        \begin{itemize}
            \item Assumes both players play optimally.
            \item Evaluates all possible moves and their outcomes.
        \end{itemize}
        \begin{lstlisting}[language=Python]
        function minimax(node, depth, maximizingPlayer):
            if depth == 0 or node is a terminal node:
                return value of node
            if maximizingPlayer:
                ...
        \end{lstlisting}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Alpha-Beta Pruning}
    \begin{block}{Optimizing Minimax}
        \begin{itemize}
            \item Eliminates branches that do not need to be assessed.
            \item Defines \textbf{alpha} and \textbf{beta} values:
            \begin{itemize}
                \item **Alpha**: Best option for the maximizing player.
                \item **Beta**: Best option for the minimizing player.
            \end{itemize}
        \end{itemize}
        \begin{lstlisting}[language=Python]
        function alphabeta(node, depth, alpha, beta, maximizingPlayer):
            if depth == 0 or node is a terminal node:
                return value of node
            if maximizingPlayer:
                ...
        \end{lstlisting}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Implementation and Preparation}
    \begin{itemize}
        \item Students will implement both algorithms in Python.
        \item Example starter code:
        \begin{lstlisting}[language=Python]
        def minimax(board, depth, is_maximizing):
            # Function implementation here

        def alpha_beta(board, depth, alpha, beta, is_maximizing):
            # Function implementation here
        \end{lstlisting}
        \item Prepare for the lab:
        \begin{itemize}
            \item Ensure Python is set up on your computer.
            \item Review materials on game trees.
            \item Familiarize with basic game scenarios.
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Conclusion and Q\&A - Key Points Recap}
    \begin{enumerate}
        \item \textbf{Game Playing Algorithms Overview}:
        \begin{itemize}
            \item Essential for simulating intelligent decision-making in competitive environments.
            \item Rely on strategies to evaluate potential moves and outcomes.
        \end{itemize}
        
        \item \textbf{Minimax Algorithm}:
        \begin{itemize}
            \item Recursive strategy for two-player, zero-sum games.
            \item Aim: Minimize potential loss while maximizing gain.
            \item \textbf{Example}: Simplified Tic-Tac-Toe evaluates moves to decide the best play.
            \item \textbf{Formula}:
                \begin{equation}
                    \text{Choose } 
                    \begin{cases}
                        \max(\text{Current Node's value}) & \text{if Maximizer's turn} \\
                        \min(\text{Current Node's value}) & \text{if Minimizer's turn}
                    \end{cases}
                \end{equation}
        \end{itemize}
        
        \item \textbf{Alpha-Beta Pruning}:
        \begin{itemize}
            \item Enhances Minimax by eliminating unnecessary branches.
            \item Increases efficiency without losing accuracy.
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Conclusion and Q\&A - Continued Key Points}
    \begin{enumerate}
        \setcounter{enumi}{3} % Start from 4 since we continued the enumeration
        
        \item \textbf{Utility Functions}:
        \begin{itemize}
            \item Evaluate the desirability of game states numerically.
            \item Help compare and rank potential outcomes.
            \item \textbf{Example}: In chess, utility depends on remaining pieces, control of the center, etc.
        \end{itemize}
        
        \item \textbf{Applications}:
        \begin{itemize}
            \item Used in AI for games like chess, checkers, and Go.
            \item Highlights adaptability in complex gaming scenarios.
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Conclusion and Q\&A - Discussion and Engagement}
    \begin{block}{Q\&A Session}
        \begin{itemize}
            \item Open floor for questions related to specific algorithms, implementations, and applications.
            \item Consider these discussion starters:
            \begin{itemize}
                \item How might Minimax be adapted for multi-player games?
                \item In what scenarios would Alpha-Beta pruning not be beneficial?
            \end{itemize}
        \end{itemize}
    \end{block}
    
    \begin{block}{Engagement Tip}
        \begin{itemize}
            \item Implement a quick interactive demonstration using Python snippets to visualize algorithms, enhancing student engagement.
        \end{itemize}
    \end{block}

    \begin{block}{Conclusion Statement}
        \begin{itemize}
            \item Understanding game-playing algorithms equips you with essential AI techniques applicable beyond gaming, influencing decision-making systems and strategic planning.
        \end{itemize}
    \end{block}
\end{frame}


\end{document}