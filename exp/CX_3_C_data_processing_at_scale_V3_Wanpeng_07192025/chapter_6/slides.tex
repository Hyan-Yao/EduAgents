\documentclass[aspectratio=169]{beamer}

% Theme and Color Setup
\usetheme{Madrid}
\usecolortheme{whale}
\useinnertheme{rectangles}
\useoutertheme{miniframes}

% Additional Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}
\usetikzlibrary{positioning}
\usepackage{hyperref}

% Custom Colors
\definecolor{myblue}{RGB}{31, 73, 125}
\definecolor{mygray}{RGB}{100, 100, 100}
\definecolor{mygreen}{RGB}{0, 128, 0}
\definecolor{myorange}{RGB}{230, 126, 34}
\definecolor{mycodebackground}{RGB}{245, 245, 245}

% Set Theme Colors
\setbeamercolor{structure}{fg=myblue}
\setbeamercolor{frametitle}{fg=white, bg=myblue}
\setbeamercolor{title}{fg=myblue}
\setbeamercolor{section in toc}{fg=myblue}
\setbeamercolor{item projected}{fg=white, bg=myblue}
\setbeamercolor{block title}{bg=myblue!20, fg=myblue}
\setbeamercolor{block body}{bg=myblue!10}
\setbeamercolor{alerted text}{fg=myorange}

% Set Fonts
\setbeamerfont{title}{size=\Large, series=\bfseries}
\setbeamerfont{frametitle}{size=\large, series=\bfseries}
\setbeamerfont{caption}{size=\small}
\setbeamerfont{footnote}{size=\tiny}

% Document Start
\begin{document}

\frame{\titlepage}

\begin{frame}[fragile]
    \frametitle{Introduction to Advanced SQL}
    \begin{block}{Overview of Key Topics}
        \begin{enumerate}
            \item Joins
            \item Subqueries
            \item Aggregate Functions
        \end{enumerate}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Joins in SQL}
    \begin{block}{Definition}
        Joins are fundamental in relational databases, allowing us to combine rows from two or more tables based on a related column, essential for analyzing data spread across different tables.
    \end{block}

    \begin{block}{Types of Joins}
        \begin{itemize}
            \item \textbf{INNER JOIN:} 
            \begin{lstlisting}
              SELECT Orders.OrderID, Customers.CustomerName
              FROM Orders
              INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID;
            \end{lstlisting}
            \item \textbf{LEFT JOIN (or LEFT OUTER JOIN):}
            \begin{lstlisting}
              SELECT Customers.CustomerName, Orders.OrderID
              FROM Customers
              LEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerID;
            \end{lstlisting}
            \item \textbf{RIGHT JOIN (or RIGHT OUTER JOIN):} Opposite of LEFT JOIN.
            \item \textbf{FULL JOIN (or FULL OUTER JOIN):} Combines results of both LEFT and RIGHT joins.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Subqueries in SQL}
    \begin{block}{Definition}
        A subquery is a query nested within another SQL query, providing a powerful way to retrieve data used in the main query.
    \end{block}

    \begin{block}{Types of Subqueries}
        \begin{itemize}
            \item \textbf{Single-row Subquery:}
            \begin{lstlisting}
              SELECT CustomerName
              FROM Customers
              WHERE City = (SELECT City FROM Customers WHERE CustomerID = 1);
            \end{lstlisting}
            \item \textbf{Multi-row Subquery:}
            \begin{lstlisting}
              SELECT ProductName
              FROM Products
              WHERE CategoryID IN (SELECT CategoryID FROM Categories WHERE CategoryName = 'Beverages');
            \end{lstlisting}
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Aggregate Functions}
    \begin{block}{Definition}
        Aggregate functions perform calculations on a set of values and return a single value, crucial for summarizing data.
    \end{block}

    \begin{block}{Common Aggregate Functions}
        \begin{itemize}
            \item \textbf{COUNT():}
            \begin{lstlisting}
              SELECT COUNT(OrderID) AS TotalOrders FROM Orders;
            \end{lstlisting}
            \item \textbf{SUM():}
            \begin{lstlisting}
              SELECT SUM(Amount) AS TotalSales FROM Sales;
            \end{lstlisting}
            \item \textbf{AVG():}
            \begin{lstlisting}
              SELECT AVG(Price) AS AveragePrice FROM Products;
            \end{lstlisting}
            \item \textbf{MAX() and MIN():} Determine highest and lowest values in a column.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Conclusion}
    Mastering these advanced SQL concepts—Joins, Subqueries, and Aggregate Functions—empowers you to perform intricate data analyses, providing you with the tools to turn raw data into actionable insights.
\end{frame}

\begin{frame}[fragile]{Learning Objectives - Introduction}
    \begin{block}{Overview}
        By the end of this chapter, you will achieve several key learning objectives in Advanced SQL for Data Analysis:
    \end{block}
\end{frame}

\begin{frame}[fragile]{Learning Objectives - Master Advanced SQL Techniques}
    \begin{enumerate}
        \item \textbf{Master Advanced SQL Techniques:}
        \begin{itemize}
            \item Understand and use complex SQL queries beyond basic SELECT statements.
            \item Focus on advanced operations such as joins, subqueries, and nested queries for deeper data manipulation.
        \end{itemize}
        
        \begin{block}{Example}
        \begin{lstlisting}[language=sql]
SELECT customer_id, total_amount
FROM orders
WHERE total_amount > (SELECT AVG(total_amount) FROM orders);
        \end{lstlisting}
        \end{block}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]{Learning Objectives - Utilise Joins Effectively}
    \begin{enumerate}
        \setcounter{enumi}{1}
        \item \textbf{Utilize Joins Effectively:}
        \begin{itemize}
            \item Proficiency in using different types of joins (INNER, LEFT, RIGHT, FULL) to combine rows from two or more tables.
            \item Understand when to use each type of join and the data they return.
        \end{itemize}
        
        \begin{block}{Example}
        \begin{lstlisting}[language=sql]
SELECT customers.name, orders.order_date 
FROM customers 
INNER JOIN orders ON customers.id = orders.customer_id;
        \end{lstlisting}
        \end{block}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]{Learning Objectives - Employ Aggregate Functions}
    \begin{enumerate}
        \setcounter{enumi}{2}
        \item \textbf{Employ Aggregate Functions:}
        \begin{itemize}
            \item Use SQL’s aggregate functions (SUM, AVG, COUNT, MAX, MIN) for data summarization.
            \item Combine aggregate functions with GROUP BY clauses to segment data effectively.
        \end{itemize}
        
        \begin{block}{Example}
        \begin{lstlisting}[language=sql]
SELECT category, SUM(total_amount) AS total_sales
FROM orders
GROUP BY category;
        \end{lstlisting}
        \end{block}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]{Learning Objectives - Develop Analytical Skills}
    \begin{enumerate}
        \setcounter{enumi}{3}
        \item \textbf{Develop Analytical Skills:}
        \begin{itemize}
            \item Enhance capabilities to interpret data for decision-making.
            \item Recognize patterns and trends for actionable insights.
        \end{itemize}
        
        \item \textbf{Implement Best Practices:}
        \begin{itemize}
            \item Understand SQL best practices for performance optimization and maintainability.
            \item Importance of commenting and structuring SQL code for clarity.
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]{Learning Objectives - Key Points and Conclusion}
    \begin{block}{Key Points to Remember}
        \begin{itemize}
            \item Mastering advanced SQL is crucial for thorough data analysis.
            \item Proficiency in joins and subqueries enhances querying capabilities.
            \item Aggregate functions allow for efficient data summarization of large datasets.
        \end{itemize}
    \end{block}

    \begin{block}{Conclusion}
        Mastering advanced SQL techniques empowers you to conduct sophisticated data analyses, leading to better-informed decisions and strategic advantages.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Overview of Joins}
    
    \begin{block}{Introduction to SQL Joins}
        In SQL, **Joins** are used to combine records from two or more tables based on related columns.
        Understanding joins is crucial for accurate data analysis and retrieving meaningful insights.
        This presentation covers the primary types of joins: **INNER JOIN**, **LEFT JOIN**, **RIGHT JOIN**, and **FULL JOIN**.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Types of Joins}

    \begin{enumerate}
        \item \textbf{INNER JOIN}
        \begin{itemize}
            \item \textbf{Definition}: Returns only the rows with matching values in both tables.
            \item \textbf{Use Case}: Retrieve records that are common to both tables.
            \item \textbf{Example}: 
            \begin{lstlisting}[language=SQL]
SELECT employees.name, departments.name 
FROM employees 
INNER JOIN departments ON employees.department_id = departments.id;
            \end{lstlisting}
        \end{itemize}

        \item \textbf{LEFT JOIN (or LEFT OUTER JOIN)}
        \begin{itemize}
            \item \textbf{Definition}: Returns all rows from the left table and matched rows from the right table (NULL if no match).
            \item \textbf{Use Case}: Get all records from the left table, regardless of matches.
            \item \textbf{Example}: 
            \begin{lstlisting}[language=SQL]
SELECT employees.name, departments.name 
FROM employees 
LEFT JOIN departments ON employees.department_id = departments.id;
            \end{lstlisting}
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Types of Joins (cont.)}

    \begin{enumerate}
        \setcounter{enumi}{2}
        \item \textbf{RIGHT JOIN (or RIGHT OUTER JOIN)}
        \begin{itemize}
            \item \textbf{Definition}: Returns all rows from the right table and matched rows from the left (NULL if no match).
            \item \textbf{Use Case}: Get all records from the right table, regardless of matches.
            \item \textbf{Example}: 
            \begin{lstlisting}[language=SQL]
SELECT employees.name, departments.name 
FROM employees 
RIGHT JOIN departments ON employees.department_id = departments.id;
            \end{lstlisting}
        \end{itemize}

        \item \textbf{FULL JOIN (or FULL OUTER JOIN)}
        \begin{itemize}
            \item \textbf{Definition}: Returns all rows when there is a match in one of the tables (NULL for non-matching rows).
            \item \textbf{Use Case}: Get a complete view of both tables, including all unmatched records.
            \item \textbf{Example}: 
            \begin{lstlisting}[language=SQL]
SELECT employees.name, departments.name 
FROM employees 
FULL JOIN departments ON employees.department_id = departments.id;
            \end{lstlisting}
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Points and Conclusion}

    \begin{block}{Key Points to Emphasize}
        \begin{itemize}
            \item Joins allow viewing data from multiple tables and are essential in relational database management.
            \item Understanding when to use each type of join is critical for ensuring correct query results.
            \item Visualizing join results clarifies how data from different tables interrelates.
        \end{itemize}
    \end{block}

    \begin{block}{Conclusion}
        Joins are a foundational concept in SQL that empower data analysts to craft complex queries and gain insights from interconnected datasets. 
        By mastering these join types, you'll enhance your ability to perform effective SQL data analysis.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Next Steps}
    In the following slide, we'll dive deeper into the **INNER JOIN** and explore its functionality along with practical examples.
\end{frame}

\begin{frame}[fragile]
    \frametitle{INNER JOIN - Introduction}
    \begin{itemize}
        \item An INNER JOIN is a SQL operation to combine rows from two or more tables based on a related column.
        \item Only returns rows where there is a match in both tables.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{INNER JOIN - How It Works}
    \begin{itemize}
        \item Compares each row of the first table with every row of the second table.
        \item Matches rows based on a specified condition (usually a common column).
        \item Excludes rows without matches.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{INNER JOIN - SQL Syntax}
    The general syntax for using an INNER JOIN is as follows:
    \begin{lstlisting}[language=SQL]
SELECT column1, column2, ...
FROM table1
INNER JOIN table2
ON table1.common_column = table2.common_column;
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{INNER JOIN - Example Scenario}
    \textbf{Table: Customers}
    \begin{center}
        \begin{tabular}{|c|c|c|}
            \hline
            CustomerID & CustomerName & Country \\
            \hline
            1 & Alice & USA \\
            2 & Bob & Canada \\
            3 & Charlie & UK \\
            \hline
        \end{tabular}
    \end{center}
    
    \textbf{Table: Orders}
    \begin{center}
        \begin{tabular}{|c|c|c|}
            \hline
            OrderID & CustomerID & OrderDate \\
            \hline
            101 & 1 & 2023-06-01 \\
            102 & 2 & 2023-06-03 \\
            103 & 1 & 2023-06-04 \\
            104 & 4 & 2023-06-05 \\
            \hline
        \end{tabular}
    \end{center}
\end{frame}

\begin{frame}[fragile]
    \frametitle{INNER JOIN - Query Example}
    To find all orders along with customer names:
    \begin{lstlisting}[language=SQL]
SELECT Customers.CustomerName, Orders.OrderID
FROM Customers
INNER JOIN Orders
ON Customers.CustomerID = Orders.CustomerID;
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{INNER JOIN - Result}
    Result of the INNER JOIN query:
    \begin{center}
        \begin{tabular}{|c|c|}
            \hline
            CustomerName & OrderID \\
            \hline
            Alice & 101 \\
            Bob & 102 \\
            Alice & 103 \\
            \hline
        \end{tabular}
    \end{center}
    \begin{itemize}
        \item Only rows with matching CustomerID (1 and 2) are included.
        \item The row with CustomerID 4 from Orders is excluded (no match).
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{INNER JOIN - Key Takeaways}
    \begin{itemize}
        \item INNER JOIN combines related data across tables, returning only matched rows.
        \item Essential for SQL data analysis.
        \item Ensure accurate join conditions to represent table relationships.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{INNER JOIN - Next Steps}
    Next, we will explore the LEFT JOIN, which retrieves all records from the left table and matched records from the right.
\end{frame}

\begin{frame}[fragile]
    \frametitle{LEFT JOIN - Overview}
    \begin{block}{Overview of LEFT JOIN}
        In SQL, a \textbf{LEFT JOIN} (or \textbf{LEFT OUTER JOIN}) is a powerful operation used to combine records from two or more tables based on a related column between them. 
        The key characteristic of a LEFT JOIN is that it returns all records from the left table (the first specified table) and the matched records from the right table (the second specified table). If there is no match, NULL values are filled in for the columns from the right table.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{LEFT JOIN - Key Points}
    \begin{itemize}
        \item \textbf{Complete Retention of Left Table Data}: All rows from the left table are preserved, regardless of whether a corresponding row in the right table exists.
        
        \item \textbf{NULL Values for Unmatched Rows}: When there is no corresponding row in the right table, the result will contain NULL in place of the right table's columns.
        
        \item \textbf{Use Cases}: LEFT JOIN is particularly useful when you want to highlight all entries from one table, regardless of whether they have associated records in another table.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{LEFT JOIN - SQL Syntax}
    \begin{block}{SQL Syntax}
    \begin{lstlisting}
SELECT columns
FROM left_table
LEFT JOIN right_table
ON left_table.common_field = right_table.common_field;
    \end{lstlisting}
    \end{block}

    \begin{itemize}
        \item \texttt{columns}: Specify the columns you want to retrieve.
        \item \texttt{left\_table}: The table you are selecting from (the one on the left).
        \item \texttt{right\_table}: The table you are joining to (the one on the right).
        \item \texttt{common\_field}: The column that links the two tables logically.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{LEFT JOIN - Example}
    Consider the following two tables:

    \begin{block}{Customers (left table)}
    \begin{tabular}{|c|l|}
    \hline
    CustomerID & CustomerName \\
    \hline
    1          & Alice         \\
    2          & Bob           \\
    3          & Charlie       \\
    4          & David         \\
    \hline
    \end{tabular}
    \end{block}

    \begin{block}{Orders (right table)}
    \begin{tabular}{|c|c|l|}
    \hline
    OrderID & CustomerID & Product     \\
    \hline
    101     & 1          & Laptop      \\
    102     & 2          & Smartphone   \\
    103     & 1          & Tablet      \\
    \hline
    \end{tabular}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{LEFT JOIN - SQL Query and Result}
    \begin{block}{SQL Query Using LEFT JOIN}
    \begin{lstlisting}
SELECT Customers.CustomerID, Customers.CustomerName, Orders.Product
FROM Customers
LEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerID;
    \end{lstlisting}
    \end{block}

    \begin{block}{Result of the Query}
    \begin{tabular}{|c|l|l|}
    \hline
    CustomerID & CustomerName & Product     \\
    \hline
    1          & Alice         & Laptop      \\
    1          & Alice         & Tablet      \\
    2          & Bob           & Smartphone   \\
    3          & Charlie       & NULL        \\
    4          & David         & NULL        \\
    \hline
    \end{tabular}
    \end{block}

    In this example:
    \begin{itemize}
        \item Alice has two orders, so her name appears twice along with different products.
        \item Bob has one order.
        \item Charlie and David do not have any orders, which is indicated by NULL values in the Product column.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{RIGHT JOIN - Concept}
    A \textbf{RIGHT JOIN} (or RIGHT OUTER JOIN) is a type of SQL join that retrieves:
    \begin{itemize}
        \item All records from the \textbf{right table} (the second table in the join statement)
        \item Matched records from the \textbf{left table} (the first table)
    \end{itemize}
    If there is no match, NULL values are returned for the columns from the left table.
    \begin{block}{Use Case}
        RIGHT JOIN is useful when you want to ensure that all records from the right table are included in the result set, regardless of whether there are corresponding entries in the left table.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{RIGHT JOIN - Syntax}
    The basic syntax for a RIGHT JOIN is as follows:
    \begin{lstlisting}[language=SQL]
SELECT columns
FROM left_table
RIGHT JOIN right_table
ON left_table.common_column = right_table.common_column;
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{RIGHT JOIN - Example}
    Consider the following two tables:
    
    \textbf{Employees}:
    \begin{tabular}{|c|c|}
        \hline
        EmployeeID & Name \\
        \hline
        1 & Alice \\
        2 & Bob \\
        3 & Charlie \\
        \hline
    \end{tabular}
    
    \textbf{Departments}:
    \begin{tabular}{|c|c|c|}
        \hline
        DepartmentID & DepartmentName & EmployeeID \\
        \hline
        1 & HR & 1 \\
        2 & IT & 2 \\
        3 & Marketing & NULL \\
        \hline
    \end{tabular}
    
    \textbf{SQL Query:}
    \begin{lstlisting}[language=SQL]
SELECT Employees.Name, Departments.DepartmentName
FROM Employees
RIGHT JOIN Departments ON Employees.EmployeeID = Departments.EmployeeID;
    \end{lstlisting}
    
    \textbf{Result:}
    \begin{tabular}{|c|c|}
        \hline
        Name & DepartmentName \\
        \hline
        Alice & HR \\
        Bob & IT \\
        NULL & Marketing \\
        \hline
    \end{tabular}
\end{frame}

\begin{frame}[fragile]
    \frametitle{FULL JOIN - Overview}
    \begin{block}{Understanding FULL JOIN}
        A \textbf{FULL JOIN}, also known as a \textbf{FULL OUTER JOIN}, is a type of join in SQL that returns all records from both tables involved in the join. It provides a comprehensive view of both datasets, including unmatched records.
    \end{block}
    
    \begin{itemize}
        \item \textbf{Definition}: Combines results of both LEFT JOIN and RIGHT JOIN.
        \item \textbf{NULL Handling}: Returns NULL for unmatched columns.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{FULL JOIN - Syntax and Operation}
    \begin{block}{Syntax}
    \begin{lstlisting}[language=SQL]
SELECT column1, column2, ...
FROM table1
FULL JOIN table2
ON table1.common_column = table2.common_column;
    \end{lstlisting}
    \end{block}
    
    \begin{itemize}
        \item \textbf{How It Works}:
            \begin{enumerate}
                \item Returns every row from both tables.
                \item Inserts NULL for non-matching columns.
            \end{enumerate}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{FULL JOIN - Example}
    \begin{block}{Example Tables}
        \textbf{Employees Table:}
        \begin{tabular}{|c|c|}
            \hline
            EmployeeID & EmployeeName \\
            \hline
            1 & Alice \\
            2 & Bob \\
            3 & Charlie \\
            \hline
        \end{tabular}
        
        \vspace{1em}
        
        \textbf{Departments Table:}
        \begin{tabular}{|c|c|}
            \hline
            DepartmentID & EmployeeID \\
            \hline
            A & 1 \\
            B & 2 \\
            C & 4 \\
            \hline
        \end{tabular}
    \end{block}

    \begin{block}{FULL JOIN Query}
    \begin{lstlisting}[language=SQL]
SELECT Employees.EmployeeID, Employees.EmployeeName, Departments.DepartmentID
FROM Employees
FULL JOIN Departments ON Employees.EmployeeID = Departments.EmployeeID;
    \end{lstlisting}
    \end{block}

    \begin{block}{Result Set}
    \begin{tabular}{|c|c|c|}
        \hline
        EmployeeID & EmployeeName & DepartmentID \\
        \hline
        1 & Alice & A \\
        2 & Bob & B \\
        3 & Charlie & NULL \\
        NULL & NULL & C \\
        \hline
    \end{tabular}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Subqueries}
    \begin{block}{Definition of Subqueries}
    A \textbf{subquery}, also known as a nested query or inner query, is a SQL query embedded within another SQL query. It allows you to perform operations that require multiple steps, enabling you to retrieve, manipulate, and analyze data in a more efficient and organized manner.
    \end{block}
    \begin{itemize}
        \item Can return a single value, a row, multiple rows, or a complete table
        \item Usable in SELECT, INSERT, UPDATE, and DELETE statements
        \item Executed before the main query
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Utilizing Subqueries - SELECT & INSERT}
    
    \begin{block}{1. Subqueries in a SELECT Statement}
    Example: Find all employees whose salaries are above the average salary in the company.
    \begin{lstlisting}[language=SQL]
SELECT employee_id, employee_name 
FROM employees 
WHERE salary > (SELECT AVG(salary) FROM employees);
    \end{lstlisting}
    \end{block}
    \begin{block}{Explanation}
    The inner query calculates the average salary. The outer query retrieves employees with salaries greater than this average.
    \end{block}

    \begin{block}{2. Subqueries in an INSERT Statement}
    Example: Insert new employees who are in the same department as ‘John Doe’.
    \begin{lstlisting}[language=SQL]
INSERT INTO employees (employee_name, department_id) 
SELECT 'Jane Smith', department_id 
FROM employees 
WHERE employee_name = 'John Doe';
    \end{lstlisting}
    \end{block}
    \begin{block}{Explanation}
    The subquery retrieves the department ID of 'John Doe', allowing the new employee to be inserted into the correct department.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Utilizing Subqueries - UPDATE & DELETE}

    \begin{block}{3. Subqueries in an UPDATE Statement}
    Example: Update the salary of employees in the ‘Sales’ department to 10\% more than the average salary of that department.
    \begin{lstlisting}[language=SQL]
UPDATE employees 
SET salary = salary * 1.10 
WHERE department_id = (SELECT department_id FROM departments WHERE department_name = 'Sales');
    \end{lstlisting}
    \end{block}
    \begin{block}{Explanation}
    The subquery retrieves the department ID for 'Sales', and the outer query updates the salaries of corresponding employees.
    \end{block}

    \begin{block}{4. Subqueries in a DELETE Statement}
    Example: Delete employees who do not belong to any department.
    \begin{lstlisting}[language=SQL]
DELETE FROM employees 
WHERE department_id NOT IN (SELECT department_id FROM departments);
    \end{lstlisting}
    \end{block}
    \begin{block}{Explanation}
    The inner query identifies valid department IDs. The outer query deletes employees not associated with any department.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Points and Conclusion}
    \begin{itemize}
        \item Subqueries provide a powerful tool for data manipulation and retrieval.
        \item Allow for complex queries to be broken down into simpler components.
        \item Mastery of subqueries is essential for advanced data analysis and manipulation in SQL.
    \end{itemize}
    \begin{block}{Conclusion}
    Subqueries enhance SQL’s capability by allowing you to perform dynamic queries based on other queries.
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Types of Subqueries}
    A subquery is a query embedded within another SQL query. 
    Understanding the types of subqueries—single-row, multi-row, and correlated—is crucial for effective data analysis.
\end{frame}

\begin{frame}[fragile]
    \frametitle{1. Single-row Subqueries}
    \begin{itemize}
        \item \textbf{Definition}: Return a single row from the inner query.
        \item \textbf{Usage}: Often used with comparison operators (=, <, >).
    \end{itemize}
    \begin{block}{Example}
        \begin{lstlisting}
SELECT employee_id, first_name, last_name
FROM employees
WHERE salary = (SELECT MAX(salary) FROM employees);
        \end{lstlisting}
    \end{block}
    \begin{itemize}
        \item \textbf{Explanation}: The inner query finds the maximum salary.
        The outer query retrieves the details of the employee earning that salary.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{2. Multi-row Subqueries}
    \begin{itemize}
        \item \textbf{Definition}: Return multiple rows from the inner query.
        \item \textbf{Usage}: Typically used with operators such as IN, ANY, or ALL.
    \end{itemize}
    \begin{block}{Example}
        \begin{lstlisting}
SELECT product_name
FROM products
WHERE category_id IN (SELECT category_id FROM categories WHERE category_name LIKE 'Electronics%');
        \end{lstlisting}
    \end{block}
    \begin{itemize}
        \item \textbf{Explanation}: The inner query selects category IDs related to 'Electronics',
        and the outer query retrieves the names of products in those categories.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{3. Correlated Subqueries}
    \begin{itemize}
        \item \textbf{Definition}: A subquery that depends on the outer query for its values; executed repeatedly.
        \item \textbf{Usage}: Used in scenarios requiring row-by-row comparisons.
    \end{itemize}
    \begin{block}{Example}
        \begin{lstlisting}
SELECT e1.first_name, e1.salary
FROM employees e1
WHERE e1.salary > (SELECT AVG(e2.salary) 
                    FROM employees e2 
                    WHERE e1.department_id = e2.department_id);
        \end{lstlisting}
    \end{block}
    \begin{itemize}
        \item \textbf{Explanation}: For each employee, the inner query calculates the average salary of their department,
        allowing comparisons against their salary.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Key Points to Remember}
    \begin{itemize}
        \item \textbf{Performance}: Correlated subqueries can be less efficient than single-row or multi-row subqueries.
        \item \textbf{Nesting}: Subqueries can be nested; you can have a subquery within a subquery.
        \item \textbf{Use Cases}:
        \begin{itemize}
            \item Use \textbf{single-row} for specific values.
            \item Use \textbf{multi-row} for lists of values.
            \item Use \textbf{correlated} for context-dependent comparisons.
        \end{itemize}
    \end{itemize}
    Understanding these various types of subqueries will enhance your ability to extract valuable insights from your datasets using SQL commands effectively.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Introduction to Aggregate Functions in SQL}
    Aggregate functions are essential tools in SQL that allow you to perform calculations on multiple rows of a dataset, resulting in a single summary value. 
    \begin{itemize}
        \item Help in data analysis.
        \item Extract meaningful insights from vast datasets.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Aggregate Functions}
    \begin{enumerate}
        \item \textbf{COUNT()}
            \begin{itemize}
                \item Description: Returns the number of rows that match a specified criterion.
                \item Example:
                \begin{lstlisting}
SELECT COUNT(*) FROM employees WHERE department = 'Sales';
                \end{lstlisting}
                \item Output: Total number of employees in the Sales department.
            \end{itemize}
        
        \item \textbf{SUM()}
            \begin{itemize}
                \item Description: Calculates the total sum of a numeric column.
                \item Example:
                \begin{lstlisting}
SELECT SUM(salary) FROM employees WHERE department = 'Sales';
                \end{lstlisting}
                \item Output: Total salary paid to employees in the Sales department.
            \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{More Key Aggregate Functions}
    \begin{enumerate}
        \setcounter{enumi}{2} % Continue from the previous frame
        \item \textbf{AVG()}
            \begin{itemize}
                \item Description: Computes the average value of a numeric column.
                \item Example:
                \begin{lstlisting}
SELECT AVG(salary) FROM employees WHERE department = 'Sales';
                \end{lstlisting}
                \item Output: Average salary of employees in the Sales department.
            \end{itemize}
        
        \item \textbf{MIN()}
            \begin{itemize}
                \item Description: Identifies the minimum value in a specified column.
                \item Example:
                \begin{lstlisting}
SELECT MIN(salary) FROM employees WHERE department = 'Sales';
                \end{lstlisting}
                \item Output: Lowest salary among employees in the Sales department.
            \end{itemize}
        
        \item \textbf{MAX()}
            \begin{itemize}
                \item Description: Identifies the maximum value in a specified column.
                \item Example:
                \begin{lstlisting}
SELECT MAX(salary) FROM employees WHERE department = 'Sales';
                \end{lstlisting}
                \item Output: Highest salary among employees in the Sales department.
            \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Importance of Aggregate Functions}
    \begin{itemize}
        \item \textbf{Data Summarization:} Condense large volumes of data into summary statistics.
        \item \textbf{Business Insights:} Provides critical insights into key performance indicators (KPIs).
        \item \textbf{Foundation for Reports:} Fundamental in generating reports and dashboards for informed decision-making.
    \end{itemize}
    \begin{block}{Summary Formula}
    Aggregate functions follow a similar syntax:
    \[
    \text{SELECT AGGREGATE\_FUNCTION(column\_name) FROM table\_name WHERE condition;}
    \]
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Points to Remember}
    \begin{itemize}
        \item Aggregate functions can be used with the \texttt{GROUP BY} clause to perform operations on subsets of data.
        \item They can also be combined with the \texttt{HAVING} clause to filter results after aggregation.
        \item Ensure appropriate data types (e.g., numerical columns for \texttt{SUM} and \texttt{AVG}).
    \end{itemize}
    \begin{block}{Next Procedures}
        Explore combining these functions with \texttt{GROUP BY} and \texttt{HAVING} clauses for advanced data analysis capabilities!
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Using Aggregate Functions - Overview}
    \begin{block}{Overview}
        Aggregate functions in SQL enable calculations across rows and return a single value. When combined with `GROUP BY` and `HAVING`, they group and filter data based on aggregate criteria.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Using Aggregate Functions - Key Concepts}
    \begin{itemize}
        \item \textbf{Aggregate Functions}:
            \begin{itemize}
                \item \texttt{COUNT()}: Number of records.
                \item \texttt{SUM()}: Total value of a numeric column.
                \item \texttt{AVG()}: Average value of a numeric column.
                \item \texttt{MIN()}: Smallest value in a column.
                \item \texttt{MAX()}: Largest value in a column.
            \end{itemize}

        \item \textbf{GROUP BY Clause}:
            \begin{block}{Syntax}
                \begin{lstlisting}
SELECT column1, aggregate_function(column2)
FROM table_name
GROUP BY column1;
                \end{lstlisting}
            \end{block}

        \item \textbf{HAVING Clause}:
            \begin{block}{Syntax}
                \begin{lstlisting}
SELECT column1, aggregate_function(column2)
FROM table_name
GROUP BY column1
HAVING condition;
                \end{lstlisting}
            \end{block}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Example: Using Aggregate Functions}
    \begin{block}{Scenario}
        Consider a `Sales` table with columns: \texttt{ProductID}, \texttt{Quantity}, and \texttt{SaleDate}. We want the total quantity sold for each product with more than 100 units sold.
    \end{block}

    \begin{block}{SQL Query}
        \begin{lstlisting}
SELECT ProductID, SUM(Quantity) AS TotalQuantity
FROM Sales
GROUP BY ProductID
HAVING SUM(Quantity) > 100;
        \end{lstlisting}
    \end{block}

    \begin{block}{Query Breakdown}
        \begin{itemize}
            \item Selects \texttt{ProductID} and calculates \texttt{TotalQuantity}.
            \item Groups data by \texttt{ProductID}.
            \item Filters results to include only products with total quantity > 100.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Conclusion}
    \begin{block}{Key Points}
        \begin{itemize}
            \item Use \texttt{HAVING} for filtering results after aggregation (not in \texttt{WHERE}).
            \item \texttt{GROUP BY} must precede \texttt{HAVING} in SQL queries.
            \item Mastering these functions enhances data analysis and decision-making.
        \end{itemize}
    \end{block}
    
    \begin{block}{Takeaway}
        By understanding aggregate functions with \texttt{GROUP BY} and \texttt{HAVING}, you can perform effective data analysis in SQL.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Practical Examples}
    In this session, we will explore the practical combinations of Joins, Subqueries, and Aggregate Functions in SQL for effective data analysis.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Overview of Key Concepts}
    \begin{block}{Key SQL Components}
        \begin{itemize}
            \item Joins - Combine rows from tables.
            \item Subqueries - Nest queries for complex operations.
            \item Aggregate Functions - Calculate summaries on data sets.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{1. Joins}
    \textbf{Explanation:} Joins combine rows from two or more tables based on a related column.

    \textbf{Types of Joins:}
    \begin{itemize}
        \item \textbf{INNER JOIN:} Matches records in both tables.
        \item \textbf{LEFT JOIN:} All records from left, matched from right, nulls if no match.
        \item \textbf{RIGHT JOIN:} All records from right, matched from left, nulls if no match.
        \item \textbf{FULL JOIN:} All records where there is a match in either table.
    \end{itemize}

    \textbf{Example:}
    \begin{lstlisting}
SELECT 
    employees.name, 
    departments.department_name
FROM 
    employees
INNER JOIN 
    departments ON employees.department_id = departments.id;
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{2. Subqueries}
    \textbf{Explanation:} A subquery is a query inside another query, enabling complex filtering.

    \textbf{Example:} Find employees with salaries above the average.
    \begin{lstlisting}
SELECT 
    name, 
    salary 
FROM 
    employees 
WHERE 
    salary > (SELECT AVG(salary) FROM employees);
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{3. Aggregate Functions}
    \textbf{Explanation:} Aggregate functions perform computations on multiple values and return a single result.

    \textbf{Common Functions:} 
    \begin{itemize}
        \item COUNT(), SUM(), AVG(), MAX(), MIN()
    \end{itemize}

    \textbf{Example with GROUP BY:} Count employees in each department.
    \begin{lstlisting}
SELECT 
    department_id, 
    COUNT(*) AS number_of_employees
FROM 
    employees
GROUP BY 
    department_id;
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{4. Combining All Three}
    \textbf{Example:} Find departments with average salary > $50,000 and > 5 employees.

    \begin{lstlisting}
SELECT 
    d.department_name,
    AVG(e.salary) AS average_salary,
    COUNT(e.id) AS number_of_employees
FROM 
    departments d
INNER JOIN 
    employees e ON d.id = e.department_id
GROUP BY 
    d.department_name
HAVING 
    AVG(e.salary) > 50000 AND COUNT(e.id) > 5;
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Points to Emphasize}
    \begin{itemize}
        \item \textbf{Joins:} Facilitate cross-table connections for deeper analysis.
        \item \textbf{Subqueries:} Provide powerful filtering options using results from other queries.
        \item \textbf{Aggregate Functions:} Summarize data to uncover insights.
        \item \textbf{Combining Techniques:} Enhances SQL's capability for data insights.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Conclusion}
    Understanding Joins, Subqueries, and Aggregate Functions is vital for advanced SQL analytics. The provided examples showcase their application in real-world scenarios, yielding valuable data insights.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Case Studies - Introduction}
    \begin{block}{Overview}
        Advanced SQL techniques like joins, subqueries, and aggregate functions are essential for in-depth data analysis across industries.
    \end{block}
    
    This slide will explore real-world case studies demonstrating the application of these concepts to solve complex data challenges.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Case Study 1: E-Commerce Sales Analysis}
    
    \textbf{Background:} A large online retail company analyzes sales performance across different regions and product categories.
    
    \textbf{Objectives:}
    \begin{itemize}
        \item Identify the best-selling products by region.
        \item Analyze customer purchase behavior over time.
    \end{itemize}
    
    \textbf{SQL Techniques Used:}
    \begin{enumerate}
        \item \textbf{Joins:}
        \begin{lstlisting}
        SELECT p.product_name, r.region_name, SUM(s.amount) AS total_sales
        FROM sales s
        JOIN products p ON s.product_id = p.id
        JOIN customers c ON s.customer_id = c.id
        JOIN regions r ON c.region_id = r.id
        GROUP BY p.product_name, r.region_name;
        \end{lstlisting}
        
        \item \textbf{Aggregate Functions:} 
        Calculate total sales and average purchase amounts.
    \end{enumerate}
    
    \textbf{Outcome:} Improved targeting of marketing campaigns and inventory management based on regional preferences.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Case Study 2: Financial Sector Risk Assessment}
    
    \textbf{Background:} A financial institution assesses risk levels for various investment portfolios.
    
    \textbf{Objectives:}
    \begin{itemize}
        \item Determine average returns and volatility.
        \item Identify correlations between asset classes.
    \end{itemize}
    
    \textbf{SQL Techniques Used:}
    \begin{enumerate}
        \item \textbf{Subqueries:}
        \begin{lstlisting}
        SELECT portfolio_id, AVG(return) AS average_return
        FROM investments
        WHERE risk_level > (
            SELECT AVG(risk_level) FROM investments
        )
        GROUP BY portfolio_id;
        \end{lstlisting}
        
        \item \textbf{Joins:} 
        Analyze the makeup of portfolios by connecting investments and assets tables.
    \end{enumerate}
    
    \textbf{Outcome:} Enhanced portfolio performance through improved resource allocation.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Case Study 3: Public Health Data Analysis}
    
    \textbf{Background:} A public health department analyzes health metrics across demographics.
    
    \textbf{Objectives:}
    \begin{itemize}
        \item Examine the relationship between health outcomes and socioeconomic factors.
        \item Track the effectiveness of health interventions.
    \end{itemize}
    
    \textbf{SQL Techniques Used:}
    \begin{enumerate}
        \item \textbf{Common Table Expressions (CTEs):}
        \begin{lstlisting}
        WITH health_data AS (
            SELECT d.demographic_group, AVG(h.outcome_score) AS avg_outcome
            FROM health_metrics h
            JOIN demographics d ON h.demographic_id = d.id
            GROUP BY d.demographic_group
        )
        SELECT *
        FROM health_data
        WHERE avg_outcome < threshold_value;
        \end{lstlisting}
        
        \item \textbf{Aggregate Functions:} 
        Calculate average outcomes for different demographic groups.
    \end{enumerate}
    
    \textbf{Outcome:} Policy adjustments resulting from insights led to improved health outcomes in vulnerable populations.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Points and Conclusion}
    
    \textbf{Key Points to Emphasize:}
    \begin{itemize}
        \item Real-world applications of Advanced SQL span diverse fields including retail, finance, and public health.
        \item Advanced SQL techniques help derive actionable insights from complex datasets.
        \item The combination of joins, subqueries, and aggregate functions enhances analysis capabilities.
    \end{itemize}
    
    \textbf{Conclusion:} 
    Studying these case studies demonstrates the powerful application of advanced SQL in addressing real-world data challenges, enabling deeper insights, and driving effective solutions.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Common Mistakes - Overview}
    \begin{block}{Overview}
        This slide identifies common mistakes and misconceptions related to Joins, Subqueries, and Aggregate Functions in SQL. 
        Understanding these pitfalls can enhance your data analysis skills and improve the accuracy of your queries.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Common Mistakes - Joins}
    \begin{enumerate}
        \item \textbf{Using the Wrong Join Type:} Misunderstanding the differences among INNER JOIN, LEFT JOIN, RIGHT JOIN, and FULL JOIN can lead to incorrect data retrieval.
        \begin{itemize}
            \item \textit{Example:} Using INNER JOIN when you need LEFT JOIN may cause loss of crucial data from the left table.
        \end{itemize}

        \item \textbf{Not Specifying Join Conditions:} Forgetting to define conditions (ON or USING) can lead to Cartesian products.
        \begin{itemize}
            \item \textit{Example:}
            \begin{lstlisting}[language=SQL]
SELECT *
FROM Orders o, Customers c; -- Missing join condition causes Cartesian product.
            \end{lstlisting}
        \end{itemize}
    \end{enumerate}
    \begin{block}{Key Takeaway}
        Always determine the type of join required for your analysis and include proper conditions to avoid data anomalies.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Common Mistakes - Subqueries}
    \begin{enumerate}
        \item \textbf{Inappropriate Use of Subqueries:} Using subqueries unnecessarily when a JOIN would suffice can reduce performance and complicate the code.
        \begin{itemize}
            \item \textit{Example:}
            \begin{lstlisting}[language=SQL]
SELECT CustomerName 
FROM Customers 
WHERE CustomerID IN (SELECT CustomerID FROM Orders); -- Consider using JOIN instead.
            \end{lstlisting}
        \end{itemize}

        \item \textbf{Misunderstanding Correlated Subqueries:} Failing to recognize the difference between correlated and non-correlated subqueries can lead to confusion.
    \end{enumerate}
    \begin{block}{Key Takeaway}
        Evaluate whether a JOIN can achieve the same result as a subquery and be mindful of correlated subqueries when writing queries.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Common Mistakes - Aggregate Functions}
    \begin{enumerate}
        \item \textbf{Not Grouping Appropriately:} Forgetting to use GROUP BY when employing aggregate functions can yield errors or unintended results.
        \begin{itemize}
            \item \textit{Example:}
            \begin{lstlisting}[language=SQL]
SELECT Department, COUNT(*) FROM Employees; -- This will result in an error; GROUP BY is needed.
            \end{lstlisting}
        \end{itemize}

        \item \textbf{Misusing Aggregate Functions in SELECT Statements:} Including non-aggregated fields without a proper GROUP BY clause.
        \begin{itemize}
            \item \textit{Example:}
            \begin{lstlisting}[language=SQL]
SELECT EmployeeName, SUM(Salary) FROM Employees GROUP BY Department;  -- EmployeeName cannot be used without a grouping.
            \end{lstlisting}
        \end{itemize}
    \end{enumerate}
    \begin{block}{Key Takeaway}
        Always pair aggregate functions with GROUP BY appropriately and ensure that all non-aggregated columns in your SELECT statement are properly included in the GROUP BY clause.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Final Note}
    Recognizing and avoiding these common mistakes enhances your SQL proficiency, enabling more effective data analysis. Always review your SQL queries critically to ensure accuracy and performance optimization!
\end{frame}

\begin{frame}[fragile]
    \frametitle{Conclusion and Next Steps}
    Summarize key takeaways and discuss the importance of Advanced SQL skills in data analysis careers.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Takeaways from Week 6}
    \begin{enumerate}
        \item \textbf{Advanced SQL Techniques}: 
        \begin{itemize}
            \item We explored complex SQL concepts such as Joins (INNER, LEFT, RIGHT), Subqueries, and Aggregate Functions (COUNT, SUM, AVG).
            \item Understanding how to use these effectively is crucial for rigorous data analysis.
        \end{itemize}
        
        \item \textbf{Importance of Joins}:
        \begin{itemize}
            \item Joins allow you to combine data from multiple tables based on related columns.
            \item Example: Using INNER JOIN to find customers with orders:
            \begin{lstlisting}[language=SQL]
SELECT customers.name, orders.total
FROM customers
INNER JOIN orders ON customers.id = orders.customer_id;
            \end{lstlisting}
        \end{itemize}
        
        \item \textbf{Leveraging Subqueries}:
        \begin{itemize}
            \item Subqueries enable you to nest queries within another query for more complex data retrieval.
            \item Example: Finding customers who have placed orders over \$100:
            \begin{lstlisting}[language=SQL]
SELECT name 
FROM customers 
WHERE id IN (SELECT customer_id FROM orders WHERE total > 100);
            \end{lstlisting}
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Takeaways Continued}
    \begin{itemize}
        \item \textbf{Aggregate Functions}:
        \begin{itemize}
            \item These functions help summarize data efficiently.
            \item Example: Using SUM to calculate total sales for each product:
            \begin{lstlisting}[language=SQL]
SELECT product_id, SUM(total) as total_sales 
FROM orders 
GROUP BY product_id;
            \end{lstlisting}
        \end{itemize}
        
        \item \textbf{Importance of Advanced SQL Skills}:
        \begin{itemize}
            \item \textbf{Improved Analytical Skills}: Mastery of advanced SQL enhances your problem-solving capabilities and helps in deriving insights from large datasets.
            \item \textbf{Versatile Application}: SQL is a universal language for data handling; skills acquired can be applied across various roles, from data analysis to business intelligence.
            \item \textbf{Enhanced Job Prospects}: Employers value candidates with strong SQL skills. Advanced SQL knowledge can set you apart in the job market and open doors to roles in data engineering, analytics, and beyond.
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Next Steps}
    \begin{enumerate}
        \item \textbf{Practice Regularly}: Continue to apply these concepts through practical exercises. Use platforms like LeetCode or HackerRank to find SQL challenges.
        \item \textbf{Explore Real-World Datasets}: Work with open datasets (e.g., Kaggle) to gain hands-on experience with database queries relevant to your field of interest.
        \item \textbf{Join Communities}: Become a part of online forums or local meetups where SQL enthusiasts share insights and tackle new challenges together.
        \item \textbf{Build a Portfolio}: Document your projects and examples of your SQL queries. Showcase your ability to manipulate and analyze data effectively when applying for jobs.
    \end{enumerate}
    
    By solidifying your understanding of advanced SQL, you're positioning yourself strongly for a successful career in data analysis and related fields. Happy querying!
\end{frame}


\end{document}