\documentclass[aspectratio=169]{beamer}

% Theme and Color Setup
\usetheme{Madrid}
\usecolortheme{whale}
\useinnertheme{rectangles}
\useoutertheme{miniframes}

% Additional Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}
\usetikzlibrary{positioning}
\usepackage{hyperref}

% Custom Colors
\definecolor{myblue}{RGB}{31, 73, 125}
\definecolor{mygray}{RGB}{100, 100, 100}
\definecolor{mygreen}{RGB}{0, 128, 0}
\definecolor{myorange}{RGB}{230, 126, 34}
\definecolor{mycodebackground}{RGB}{245, 245, 245}

% Set Theme Colors
\setbeamercolor{structure}{fg=myblue}
\setbeamercolor{frametitle}{fg=white, bg=myblue}
\setbeamercolor{title}{fg=myblue}
\setbeamercolor{section in toc}{fg=myblue}
\setbeamercolor{item projected}{fg=white, bg=myblue}
\setbeamercolor{block title}{bg=myblue!20, fg=myblue}
\setbeamercolor{block body}{bg=myblue!10}
\setbeamercolor{alerted text}{fg=myorange}

% Set Fonts
\setbeamerfont{title}{size=\Large, series=\bfseries}
\setbeamerfont{frametitle}{size=\large, series=\bfseries}
\setbeamerfont{caption}{size=\small}
\setbeamerfont{footnote}{size=\tiny}

% Code Listing Style
\lstdefinestyle{customcode}{
  backgroundcolor=\color{mycodebackground},
  basicstyle=\footnotesize\ttfamily,
  breakatwhitespace=false,
  breaklines=true,
  commentstyle=\color{mygreen}\itshape,
  keywordstyle=\color{blue}\bfseries,
  stringstyle=\color{myorange},
  numbers=left,
  numbersep=8pt,
  numberstyle=\tiny\color{mygray},
  frame=single,
  framesep=5pt,
  rulecolor=\color{mygray},
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2,
  captionpos=b
}
\lstset{style=customcode}

% Custom Commands
\newcommand{\hilight}[1]{\colorbox{myorange!30}{#1}}
\newcommand{\source}[1]{\vspace{0.2cm}\hfill{\tiny\textcolor{mygray}{Source: #1}}}
\newcommand{\concept}[1]{\textcolor{myblue}{\textbf{#1}}}
\newcommand{\separator}{\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}}

% Footer and Navigation Setup
\setbeamertemplate{footline}{
  \leavevmode%
  \hbox{%
  \begin{beamercolorbox}[wd=.3\paperwidth,ht=2.25ex,dp=1ex,center]{author in head/foot}%
    \usebeamerfont{author in head/foot}\insertshortauthor
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.25ex,dp=1ex,center]{title in head/foot}%
    \usebeamerfont{title in head/foot}\insertshorttitle
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.2\paperwidth,ht=2.25ex,dp=1ex,center]{date in head/foot}%
    \usebeamerfont{date in head/foot}
    \insertframenumber{} / \inserttotalframenumber
  \end{beamercolorbox}}%
  \vskip0pt%
}

% Turn off navigation symbols
\setbeamertemplate{navigation symbols}{}

% Title Page Information
\title[Search Algorithms]{Week 3: Search Algorithms}
\author[J. Smith]{John Smith, Ph.D.}
\institute[University Name]{
  Department of Computer Science\\
  University Name\\
  \vspace{0.3cm}
  Email: email@university.edu\\
  Website: www.university.edu
}
\date{\today}

% Document Start
\begin{document}

\frame{\titlepage}

\begin{frame}[fragile]
    \frametitle{Introduction to Search Algorithms}
    \begin{block}{Overview of Search Algorithms}
        Search algorithms are fundamental techniques used in computer science and artificial intelligence to explore data structures, solve problems, and navigate through various paths toward a solution. They are critical for decision-making processes, information retrieval, and optimization tasks.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{What are Search Algorithms?}
    \begin{itemize}
        \item \textbf{Definition}: A search algorithm is a procedure that defines an orderly way of discovering a solution or a path across various data states.
        \item \textbf{Purpose}: To search for specific data points or find a solution to a given problem efficiently.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Significance in AI Problem-Solving}
    \begin{itemize}
        \item \textbf{Problem Exploration}: Helps AI systems explore complex problem spaces.
        \item \textbf{Optimal Solutions}: Assists in finding the best or most efficient solutions.
        \item \textbf{State Space Navigation}: Crucial in areas like route planning, game playing, and puzzle solving.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Points to Consider}
    \begin{enumerate}
        \item \textbf{Structured Approach}: Search algorithms provide a systematic framework for problem-solving.
        \item \textbf{Efficiency Matters}: The efficiency often determines the feasibility of solutions, especially with large datasets.
        \item \textbf{Real-World Applications}: Used in navigation systems (e.g., Google Maps), AI in games (e.g., chess), and database querying.
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Examples of Search Algorithms}
    \textbf{Linear Search}
    \begin{itemize}
        \item Sequentially checks each element until the target is found. Simple but inefficient for large datasets.
    \end{itemize}
    \begin{lstlisting}[language=Python]
def linear_search(data, target):
    for index, value in enumerate(data):
        if value == target:
            return index
    return -1
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Examples of Search Algorithms (cont.)}
    \textbf{Binary Search}
    \begin{itemize}
        \item Efficiently searches sorted arrays by repeatedly dividing the search interval in half.
    \end{itemize}
    \begin{lstlisting}[language=Python]
def binary_search(data, target):
    low = 0
    high = len(data) - 1
    while low <= high:
        mid = (low + high) // 2
        if data[mid] < target:
            low = mid + 1
        elif data[mid] > target:
            high = mid - 1
        else:
            return mid
    return -1
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Conclusion and Transition}
    \begin{itemize}
        \item Search algorithms are pivotal in AI, enabling efficient solutions to complex problems.
        \item Understanding these mechanisms will lay the groundwork for specialized search algorithms in the next slide.
    \end{itemize}
    \textbf{Transition Note}: Next, we will classify search algorithms into informed and uninformed types, each with unique strategies and applications tailored to different problem-solving scenarios.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Types of Search Algorithms - Introduction}
    \begin{block}{Introduction to Search Algorithms}
        Search algorithms are foundational tools in artificial intelligence (AI), enabling the exploration of problem spaces. 
        They can be broadly classified into two categories: 
        \textbf{informed search algorithms} and \textbf{uninformed (or blind) search algorithms}. 
        Understanding the distinction between these types enhances your problem-solving techniques in AI.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Types of Search Algorithms - Uninformed}
    \begin{block}{Uninformed Search Algorithms}
        \begin{itemize}
            \item \textbf{Definition}: Uninformed search strategies do not have additional information about the goal's location other than the problem definition. They explore the search space without any guidance to find the solutions.
            
            \item \textbf{Examples}:
                \begin{enumerate}
                    \item \textbf{Breadth-First Search (BFS)}: 
                        \begin{itemize}
                            \item Explores all the nodes at the present depth before moving on to nodes at the next depth level.
                            \item \textbf{Example}: Searching for the shortest path in a tree or graph.
                        \end{itemize}
                    \item \textbf{Depth-First Search (DFS)}:
                        \begin{itemize}
                            \item Explores as far as possible down one branch before backtracking.
                            \item \textbf{Example}: Used in puzzles like mazes where path exploration is crucial.
                        \end{itemize}
                \end{enumerate}
        \end{itemize}
        
        \textbf{Key Point}: Uninformed searches guarantee finding a solution if one exists but may not be efficient in terms of time and space.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Types of Search Algorithms - Informed}
    \begin{block}{Informed Search Algorithms}
        \begin{itemize}
            \item \textbf{Definition}: Informed search strategies leverage heuristic information to estimate which direction to search, rendering the process more efficient.
            
            \item \textbf{Examples}:
                \begin{enumerate}
                    \item \textbf{A* Search Algorithm}:
                        \begin{itemize}
                            \item Combines the benefits of BFS and DFS. Uses a heuristic to estimate the cost from the start node to the goal.
                            \item \textbf{Illustration}: Navigating a map using GPS, where the algorithm prefers paths based on real-time traffic data.
                        \end{itemize}
                    \item \textbf{Greedy Best-First Search}:
                        \begin{itemize}
                            \item Selects the node that seems to be closest to the goal based on the heuristic.
                            \item \textbf{Example}: Finding a specific node in a graph where fewer hops are desired.
                        \end{itemize}
                \end{enumerate}
        \end{itemize}
        
        \textbf{Key Point}: Informed searches are typically more efficient and effective at solving problems due to the use of heuristics.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Summary and Code Snippet}
    \begin{block}{Summary}
        \begin{itemize}
            \item \textbf{Uninformed Search}: No additional knowledge about goal; examples include BFS and DFS; guaranteed to find a solution.
            \item \textbf{Informed Search}: Uses heuristics to efficiently navigate toward the goal; examples include A* and Greedy Best-First Search; typically more efficient.
        \end{itemize}
    \end{block}
    
    \begin{block}{Example Code Snippet: Breadth-First Search (Python)}
    \begin{lstlisting}[language=Python]
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    while queue:
        vertex = queue.popleft()
        if vertex not in visited:
            visited.add(vertex)
            queue.extend(graph[vertex] - visited)
    return visited
    \end{lstlisting}
    \end{block}
    
    \begin{block}{Next Steps}
        In the next slide, we will delve deeper into Uninformed Search Strategies, exploring the intricacies of BFS and DFS. Prepare to understand their implementations and strengths comprehensively!
    \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Uninformed Search Strategies - Overview}
  Uninformed search strategies (blind search strategies) explore the search space without any domain-specific knowledge. They determine the next node based solely on the structure of the search tree without heuristics.

  \begin{block}{Key Uninformed Search Strategies}
    \begin{itemize}
      \item Breadth-First Search (BFS)
      \item Depth-First Search (DFS)
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Uninformed Search Strategies - Breadth-First Search (BFS)}
  \textbf{Definition:} 
  BFS explores all the nodes at the present depth level before moving on to nodes at the next depth level. It employs a queue data structure.

  \textbf{Algorithm Steps:}
  \begin{enumerate}
    \item Initialize a queue and enqueue the starting node.
    \item Repeat until the queue is empty:
      \begin{itemize}
        \item Dequeue the front node.
        \item If the node is the goal, return the path.
        \item Otherwise, enqueue all its unvisited neighbors.
      \end{itemize}
  \end{enumerate}

  \textbf{Key Points:}
  \begin{itemize}
    \item Complete: Guaranteed to find a solution if one exists.
    \item Optimal: Finds the shortest path in an unweighted graph.
    \item Space Complexity: $O(b^d)$ where $b$ is the branching factor and $d$ is the depth of the shallowest solution.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Uninformed Search Strategies - Depth-First Search (DFS)}
  \textbf{Definition:} 
  DFS explores as far down a branch as possible before backtracking. It uses a stack (which can be implemented recursively).

  \textbf{Algorithm Steps:}
  \begin{enumerate}
    \item Initialize a stack and push the starting node.
    \item Repeat until the stack is empty:
      \begin{itemize}
        \item Pop the top node.
        \item If the node is the goal, return the path.
        \item Otherwise, push all its unvisited neighbors onto the stack.
      \end{itemize}
  \end{enumerate}

  \textbf{Key Points:}
  \begin{itemize}
    \item Not Complete: May get stuck in loops.
    \item Not Optimal: Does not guarantee the shortest path.
    \item Space Complexity: $O(b \cdot d)$ for iterative implementation.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Comparison of BFS and DFS}
  \begin{center}
    \begin{tabular}{|c|c|c|}
      \hline
      Feature               & BFS                      & DFS                     \\
      \hline
      Completeness          & Yes                     & No                      \\
      \hline
      Optimality            & Yes (unweighted)       & No                      \\
      \hline
      Space Complexity      & $O(b^d)$                & $O(b \cdot d)$        \\
      \hline
      Time Complexity       & $O(b^d)$                & $O(b^d)$              \\
      \hline
      Implementation        & Queue                   & Stack (or Recursive)    \\
      \hline
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Conclusion on Uninformed Search Strategies}
  Uninformed search strategies provide foundational knowledge for understanding more complex algorithms. BFS and DFS have unique characteristics suitable for different types of problems. 

  In upcoming slides, we will explore the Breadth-First Search algorithm in detail, including its functionalities, complexities, and typical applications.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Breadth-First Search (BFS)}
    \begin{block}{What is BFS?}
        Breadth-First Search (BFS) is an uninformed search algorithm used for traversing or searching tree or graph data structures. It explores the nodes level by level, starting from the root node and moving outward. BFS is particularly useful for finding the shortest path in an unweighted graph.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Concepts of BFS}
    \begin{itemize}
        \item \textbf{Queue Structure:}
            \begin{itemize}
                \item BFS utilizes a queue to keep track of nodes that need to be explored.
                \item Nodes are added to the queue as they are discovered and removed when they are explored.
            \end{itemize}
        \item \textbf{Levels of Exploration:}
            \begin{itemize}
                \item BFS visits all the vertices at the present depth level before moving on to the next depth level.
                \item This guarantees that the shortest path to a node is found first, assuming all edges have the same weight.
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Steps of the BFS Algorithm}
    \begin{enumerate}
        \item \textbf{Initialization:}
            \begin{itemize}
                \item Start by enqueueing the root node and marking it as visited.
                \item Create an empty queue and start processing it.
            \end{itemize}
        \item \textbf{Node Exploration:}
            \begin{itemize}
                \item While the queue is not empty:
                    \begin{itemize}
                        \item Dequeue a node and process it (e.g., print it or record it).
                        \item For each adjacent (unvisited) node of the dequeued node:
                            \begin{itemize}
                                \item Mark the adjacent node as visited.
                                \item Enqueue the adjacent node.
                            \end{itemize}
                    \end{itemize}
            \end{itemize}
        \item \textbf{Termination:}
            \begin{itemize}
                \item The algorithm continues until all reachable nodes have been visited.
            \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{BFS Pseudocode}
    \begin{lstlisting}[language=plaintext]
BFS(graph, start_node):
    create a queue Q
    create a set visited
    enqueue start_node onto Q
    mark start_node as visited
    
    while Q is not empty:
        current_node = dequeue from Q
        process(current_node)  // e.g., print the node
        
        for each neighbor in graph.adjacency_list[current_node]:
            if neighbor not in visited:
                enqueue neighbor onto Q
                mark neighbor as visited
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Examples of BFS Applications}
    \begin{itemize}
        \item \textbf{Shortest Path in Unweighted Graphs:}
            \begin{itemize}
                \item BFS is often used in navigation systems to find the shortest path from one location to another.
            \end{itemize}
        \item \textbf{Finding Connected Components:}
            \begin{itemize}
                \item In social networks, BFS can be employed to determine groups of individuals that connect directly or through other connections.
            \end{itemize}
        \item \textbf{Web Crawlers:}
            \begin{itemize}
                \item Used by search engines to crawl the internet, exploring pages level by level.
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Points to Emphasize}
    \begin{itemize}
        \item BFS guarantees the shortest path in an unweighted graph.
        \item It uses a queue for level-order traversal and can handle large graphs robustly.
        \item BFS can be more memory-intensive compared to Depth-First Search (DFS) since it stores all nodes at the current level in the queue.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Depth-First Search (DFS)}
    \begin{block}{Overview}
        Depth-First Search (DFS) is a fundamental algorithm used for traversing or searching tree or graph data structures. 
        It explores as far as possible along each branch before backtracking, ensuring that all nodes are visited systematically.
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Working Principle - Depth-First Search}
    \begin{enumerate}
        \item \textbf{Exploration Strategy:}
        \begin{itemize}
            \item DFS uses a stack (either explicitly or implicitly through recursion) to remember which nodes to explore next.
            \item It prioritizes exploring one path as deeply as possible before switching to other paths.
        \end{itemize}
        
        \item \textbf{Steps:}
        \begin{itemize}
            \item Begin at a specified node (source).
            \item Mark the node as visited.
            \item Explore an adjacent unvisited node.
            \item Repeat the process until there are no unvisited adjacent nodes.
            \item Backtrack to the most recent visited node with unvisited adjacent nodes and continue the search.
        \end{itemize}
        
        \item \textbf{Termination:} The process continues until all nodes are visited or the desired node is found.
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Code Snippet for DFS Algorithm}
    \begin{lstlisting}[language=Python]
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    
    # Explore each adjacent node
    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
    
    return visited

# Example graph represented as an adjacency list
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}

# Calling DFS
visited_nodes = dfs(graph, 'A')
print(visited_nodes)  # Output: {'A', 'B', 'D', 'E', 'F', 'C'}
    \end{lstlisting}
\end{frame}

\begin{frame}
    \frametitle{Use Cases for DFS}
    \begin{itemize}
        \item \textbf{Tree Traversal:} DFS is used to traverse or search binary trees, finding specific values or performing operations.
        \item \textbf{Pathfinding:} Useful in maze and puzzle-solving scenarios.
        \item \textbf{Topological Sorting:} Helps in ordering tasks with dependencies.
        \item \textbf{Cycle Detection:} Assists in determining cycles in directed graphs.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Key Points on DFS}
    \begin{itemize}
        \item \textbf{Efficiency:} DFS is space-efficient as it does not store all nodes at the same level, unlike BFS.
        \item \textbf{Complexity:} The time complexity is $O(V + E)$ where $V$ is the number of vertices and $E$ is the number of edges.
        \item Suitable for scenarios where solutions are deep and can be reached quickly without exploring all nodes.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Informed Search Strategies}
  \begin{block}{Introduction}
    Informed search strategies leverage domain knowledge, making algorithms smarter about which paths to explore. These methods are efficient in finding the shortest path in a search space.
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Key Concepts}
  \begin{enumerate}
    \item \textbf{Informed Search}:
      Refers to search algorithms that utilize additional information (heuristics) to improve performance compared to blind search strategies (e.g., Depth-First Search).
      
    \item \textbf{Heuristic Function (h(n))}:
      A function that estimates the cost from node \( n \) to the goal node, guiding the exploration order.
      
    \item \textbf{Optimal Search}:
      Informed search aims to find paths with optimal efficiency in terms of time and space.
  \end{enumerate}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A* Search Algorithm}
  \begin{block}{Overview}
    A* Search combines the strengths of Dijkstra’s algorithm and greedy best-first search.
  \end{block}
  \begin{block}{Evaluation Function}
    A* uses an evaluation function to prioritize node exploration:
    \[
    f(n) = g(n) + h(n)
    \]
    \begin{itemize}
      \item \( g(n) \): Cost to reach node \( n \) from the start.
      \item \( h(n) \): Estimated cost from node \( n \) to the goal (using heuristics).
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{How A* Works}
  \begin{enumerate}
    \item Start from the initial node and evaluate its \( f(n) \).
    \item Expand nodes with the lowest \( f \) value.
    \item Repeat until reaching the goal node.
  \end{enumerate}

  \begin{block}{Example: Navigating a Map}
    - \textbf{Start Node}: Your current location.\\
    - \textbf{Goal Node}: Destination.\\
    - \( g(n) \): Distance traveled so far.\\
    - \( h(n) \): Straight-line distance to the destination (e.g., using Euclidean distance).
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Other Heuristic-Based Methods}
  \begin{itemize}
    \item \textbf{Greedy Best-First Search}:
      Considers only the heuristic cost \( h(n) \) without the cost so far \( g(n) \).
      
    \item \textbf{Bidirectional Search}:
      Searches from both start and goal nodes to meet in the middle, reducing search time.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Key Points}
  \begin{enumerate}
    \item Informed search strategies outperform uninformed ones by utilizing additional knowledge.
    \item A* is popular due to its balance of depth and heuristic guidance.
    \item Selecting an effective heuristic function is crucial for optimizing search performance.
  \end{enumerate}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Conclusion}
  Informed search strategies, particularly algorithms like A*, are powerful tools for efficiently navigating complex search spaces. Mastering their implementation and optimization is vital for success in computer science and artificial intelligence.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Next Topic}
  \begin{block}{Heuristic Function}
    Understanding how heuristic functions enhance search efficiency and their practical implications.
  \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Heuristic Function - Overview}
    \begin{block}{Understanding Heuristic Functions}
        A \textbf{heuristic function}, denoted as \( h(n) \), provides an estimate of the cost or distance from a given node \( n \) to the goal node. 
        This estimate helps prioritize the exploration of paths likely to lead to an optimal solution.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Heuristic Function - Key Characteristics}
    \begin{itemize}
        \item \textbf{Estimation:} Provides an approximation of the distance or cost to reach the goal.
        \item \textbf{Guiding the Search:} Directs algorithms (e.g., A* and Greedy Best-First Search) in exploring promising paths first.
        \item \textbf{Domain-Specific:} Can be tailored to specific problem domains for better performance.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Role of Heuristic Functions in Search Efficiency}
    \begin{itemize}
        \item \textbf{Reducing the search space:} Eliminates unlikely paths based on cost estimation.
        \item \textbf{Speeding up the search process:} Algorithms like A* find optimal paths faster than uninformed methods using heuristics.
        \item \textbf{Enhancing decision-making:} Evaluates node potential without exhaustive search.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Examples of Heuristic Functions}
    \begin{enumerate}
        \item \textbf{Straight-Line Distance:}
            \begin{itemize}
                \item Common in pathfinding (e.g., GPS) using Euclidean distance.
                \item Formula: 
                \[
                h(n) = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}
                \]
                where \((x_1, y_1)\) and \((x_2, y_2)\) are coordinates of the nodes.
            \end{itemize}

        \item \textbf{Manhattan Distance:}
            \begin{itemize}
                \item Used in grid-based environments where diagonal moves are not allowed.
                \item Formula:
                \[
                h(n) = |x_2 - x_1| + |y_2 - y_1|
                \]
            \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Important Considerations for Heuristics}
    \begin{itemize}
        \item \textbf{Admissibility:} A heuristic is admissible if it never overestimates the actual cost to reach the goal, ensuring optimality for A*.
        \item \textbf{Consistency (Monotonicity):} Satisfied if:
        \[
        h(n) \leq c(n, n') + h(n')
        \]
        for every node \( n \) and every successor \( n' \). This guarantees optimal paths and simpler computations.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Conclusion}
    Heuristic functions are essential in search algorithms, significantly enhancing efficiency by providing informed estimates of goal distances. 
    By selecting or designing appropriate heuristics, we can optimize search strategies for improved performance in various applications, from artificial intelligence to robotics.
\end{frame}

\begin{frame}[fragile]
    \frametitle{A* Search Algorithm}
    \begin{block}{Overview}
        The A* (A-star) search algorithm is a widely used pathfinding and graph traversal algorithm in computer science and artificial intelligence.
        It is especially effective for finding the shortest path from a start node to a goal node in a weighted graph.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Concepts}
    \begin{itemize}
        \item A* combines the strengths of:
        \begin{itemize}
            \item Best-first search
            \item Dijkstra's algorithm
        \end{itemize}
        \item Utilizes heuristics to prioritize node exploration.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{A* Formula}
    \begin{block}{Evaluation Formula}
        The A* algorithm evaluates nodes using the formula:
        \begin{equation}
            f(n) = g(n) + h(n)
        \end{equation}
        where:
        \begin{itemize}
            \item \( f(n) \): Total estimated cost of the cheapest solution through node \(n\).
            \item \( g(n) \): Exact cost from the start node to node \(n\).
            \item \( h(n) \): Heuristic estimated cost from node \(n\) to the goal.
        \end{itemize}
    \end{block}
    \begin{block}{Note}
        The heuristic function \(h(n)\) must be admissible to guarantee the optimality of the algorithm.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{A* Algorithm Steps}
    \begin{enumerate}
        \item Initialization: Start with an open set containing the starting node and an empty closed set.
        \item Looping: While the open set is not empty:
        \begin{itemize}
            \item Choose the node \(n\) with the lowest \(f(n)\) from the open set.
            \item If \(n\) is the goal node, reconstruct and return the path.
            \item Move \(n\) to the closed set.
            \item For each neighbor of \(n\):
            \begin{itemize}
                \item Skip if in the closed set.
                \item Calculate \(g\) and \(f\) values.
                \item If not in the open set, add it. If in, check for a shorter path and update values.
            \end{itemize}
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Example of A*}
    \begin{block}{Graph Representation}
        \begin{verbatim}
        S - A - B - G
             |       |
        C - D - E - F
        \end{verbatim}
        where:
        \begin{itemize}
            \item \(S\): Start
            \item \(G\): Goal
        \end{itemize}
    \end{block}
    \begin{block}{Using A*}
        \begin{itemize}
            \item Initialize \(open\_set = \{S\}\).
            \item Calculate \(f\) values for nodes reachable from \(S\).
            \item Iteratively choose the node with the lowest \(f\) value until \(G\) is reached.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Practical Applications}
    \begin{itemize}
        \item Route Navigation: GPS systems for optimal driving routes.
        \item Game Development: AI for character movement and pathfinding.
        \item Robotics: Path planning for robots and drones.
        \item Network Routing: Optimizing data packet paths in networks.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Points to Emphasize}
    \begin{itemize}
        \item A* is optimal and complete with an admissible heuristic.
        \item Balances performance (speed) and accuracy (pathfinding).
        \item The choice of heuristic significantly affects efficiency.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Comparison of Search Algorithms - Introduction}
    \begin{block}{Introduction to Search Algorithms}
        Search algorithms are integral to problem-solving in computer science and artificial intelligence. They enable the exploration of data structures like graphs and trees, facilitating the identification of paths or solutions to problems. 
    \end{block}
    This slide will compare several popular search algorithms based on their effectiveness and efficiency.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Comparison of Search Algorithms - Key Algorithms}
    \begin{enumerate}
        \item \textbf{Linear Search}
            \begin{itemize}
                \item \textbf{Description}: Sequentially searches for an element in a list.
                \item \textbf{Time Complexity}: $O(n)$
                \item \textbf{Space Complexity}: $O(1)$
                \item \textbf{Example}: Finding a specific name in an unsorted list of names.
                \item \textbf{Illustration}: Searching for 'D' in List([A, B, C, D, E]).
            \end{itemize}

        \item \textbf{Binary Search}
            \begin{itemize}
                \item \textbf{Description}: Finds an element in a sorted list by dividing the search interval in half.
                \item \textbf{Time Complexity}: $O(\log n)$
                \item \textbf{Space Complexity}: $O(1) / O(\log n)$ (recursive)
                \item \textbf{Example}: Finding a number in a sorted array.
                \item \textbf{Illustration}: Searching for '5' in Array([1, 3, 5, 7, 9]).
            \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Comparison of Search Algorithms - Summary and Conclusion}
    \begin{block}{Summary of Effectiveness and Efficiency}
        \begin{tabular}{|c|c|c|c|}
            \hline
            Algorithm & Time Complexity & Space Complexity & Use Cases \\
            \hline
            Linear Search & $O(n)$ & $O(1)$ & Unsorted data \\
            Binary Search & $O(\log n)$ & $O(1) / O(\log n)$ & Sorted data \\
            DFS & $O(V + E)$ & $O(h)$ & Pathfinding, puzzles \\
            BFS & $O(V + E)$ & $O(V)$ & Shortest path in unweighted graphs \\
            A* & $O(E)$ & $O(E)$ & Route navigation \\
            \hline
        \end{tabular}
    \end{block}
    \begin{block}{Conclusion}
        The choice of search algorithm significantly affects effectiveness and efficiency based on the problem context. An understanding of their intricacies and performance metrics is critical for optimizing search tasks in AI applications.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Applications of Search Algorithms}
    \begin{block}{Introduction}
        Search algorithms are crucial in artificial intelligence (AI) applications, efficiently exploring large solution spaces to find optimal or satisfactory solutions.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Applications - Part 1}
    \begin{enumerate}
        \item \textbf{Web Search Engines:}
        \begin{itemize}
            \item Algorithms like PageRank rank web pages by relevance and authority.
            \item \textit{Example:} Google's algorithm assesses thousands of factors to determine the best results.
        \end{itemize}

        \item \textbf{Social Media:}
        \begin{itemize}
            \item Algorithms recommend connections and content based on interactions.
            \item \textit{Example:} Facebook suggests friends by analyzing mutual connections and past interactions.
        \end{itemize}
        
        \item \textbf{Navigation and Route Planning:}
        \begin{itemize}
            \item Algorithms such as A* and Dijkstra's are used for calculating shortest paths.
            \item \textit{Example:} Google Maps provides optimal routes considering various paths and traffic conditions.
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Applications - Part 2}
    \begin{enumerate}
        \setcounter{enumi}{3} % Continue from the previous frame
        \item \textbf{Game Development:}
        \begin{itemize}
            \item AI uses search algorithms to make decisions in games.
            \item \textit{Example:} Chess engines analyze game scenarios to determine the best next move using Minimax and Alpha-Beta pruning.
        \end{itemize}

        \item \textbf{Artificial Intelligence in Robotics:}
        \begin{itemize}
            \item Search algorithms are essential for pathfinding and obstacle avoidance.
            \item \textit{Example:} Autonomous robots utilize A* search to navigate complex environments avoiding obstacles.
        \end{itemize}

        \item \textbf{Recommendation Systems:}
        \begin{itemize}
            \item E-commerce sites recommend products based on user behavior.
            \item \textit{Example:} Amazon identifies patterns in user purchases to suggest items.
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Points to Emphasize}
    \begin{itemize}
        \item \textbf{Efficiency:} The effectiveness of a search algorithm is measured by its solution-finding speed.
        \item \textbf{Scalability:} Algorithms vary in suitability for different problem scales; context is key.
        \item \textbf{Complexity:} The choice of algorithm significantly impacts performance concerning time and space complexities.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Algorithm Complexity}
    \begin{block}{Introduction}
    Introduction to time and space complexity in search algorithms, including Big O notation.
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Understanding Algorithm Complexity}
    \begin{itemize}
        \item Algorithm complexity measures performance changes as input size changes.
        \item Two types of complexity:
        \begin{itemize}
            \item \textbf{Time Complexity}: Time taken by an algorithm as a function of input size ($n$).
            \item \textbf{Space Complexity}: Memory space required by an algorithm as a function of input size.
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Time Complexity}
    \begin{itemize}
        \item Time complexity is expressed using \textbf{Big O Notation}:
        \begin{itemize}
            \item Describes the worst-case execution time.
            \item Helps compare efficiency of algorithms regardless of machine specifics.
        \end{itemize}
        \item \textbf{Common Time Complexities}:
        \begin{itemize}
            \item $O(1)$: Constant Time (e.g., array access)
            \item $O(\log n)$: Logarithmic Time (e.g., binary search)
            \item $O(n)$: Linear Time (e.g., linear search)
            \item $O(n \log n)$: Linearithmic Time (e.g., efficient sorting)
            \item $O(n^2)$: Quadratic Time (e.g., bubble sort)
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Comparing Search Algorithms}
    Example:
    \begin{itemize}
        \item \textbf{Linear Search}: $O(n)$ - checks each element one by one.
        \item \textbf{Binary Search}: $O(\log n)$ - divides the search interval in half.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Space Complexity}
    \begin{itemize}
        \item Space complexity is the total memory space required, including both:
        \begin{itemize}
            \item Temporary space during execution.
            \item Space needed for input data.
        \end{itemize}
        \item \textbf{Key Concepts}:
        \begin{itemize}
            \item \textbf{Auxiliary Space}: Extra space used apart from the input data.
        \end{itemize}
        \item \textbf{Common Space Complexities}:
        \begin{itemize}
            \item $O(1)$: Constant Space (fixed space algorithms).
            \item $O(n)$: Linear Space (storing elements in an array).
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Key Points}
    \begin{itemize}
        \item Understanding time and space complexity is crucial for efficient algorithm selection.
        \item Big O notation provides a standardized comparison framework.
        \item Different search algorithms exhibit varied complexities, influencing performance significantly.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Example Code Snippet: Linear vs. Binary Search}
    \begin{block}{Linear Search}
    \begin{lstlisting}[language=Python]
def linear_search(arr, target):
    for index in range(len(arr)):
        if arr[index] == target:
            return index
    return -1
    \end{lstlisting}
    \end{block}
    \begin{block}{Binary Search (requires sorted array)}
    \begin{lstlisting}[language=Python]
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
    \end{lstlisting}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Conclusion}
    \begin{itemize}
        \item Mastering algorithm complexity is essential for optimizing search algorithms.
        \item It aids in understanding efficiency and is vital in real-world applications, such as AI.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Performance Metrics}
    \begin{block}{Understanding Performance Metrics}
        When evaluating search algorithms in AI, we analyze various performance metrics to assess their effectiveness in finding solutions.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Performance Metrics - Key Metrics}
    \begin{enumerate}
        \item \textbf{Time Complexity}
        \begin{itemize}
            \item Definition: Time an algorithm takes as a function of input size.
            \item Measurement: Expressed in Big O notation (e.g., O(n) for linear search, O(log n) for binary search).
        \end{itemize}

        \item \textbf{Space Complexity}
        \begin{itemize}
            \item Definition: Memory required in relation to input size.
            \item Measurement: Also using Big O notation (e.g., space for call stack in recursive algorithms).
        \end{itemize}

        \item \textbf{Success Rate}
        \begin{itemize}
            \item Definition: Percentage of successful searches.
            \item Importance: Indicates algorithm reliability.
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Performance Metrics - Additional Metrics}
    \begin{enumerate}
        \setcounter{enumi}{3}
        \item \textbf{Average Search Depth}
        \begin{itemize}
            \item Definition: Average number of nodes explored.
            \item Calculation: Helps understand efficiency in traversing search space.
        \end{itemize}

        \item \textbf{Redundant Nodes}
        \begin{itemize}
            \item Definition: Number of revisitations to nodes.
            \item Impact: Reducing redundancy improves time complexity.
        \end{itemize}

        \item \textbf{Real-Time Performance}
        \begin{itemize}
            \item Definition: Efficiency during practical execution.
            \item Consideration: Variations in input and resources affect performance.
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Points and Real-World Example}
    \begin{block}{Key Points to Remember}
        \begin{itemize}
            \item Different search algorithms have varying complexities; understanding these helps in choice selection.
            \item Applications in AI depend heavily on performance metrics.
            \item Both theoretical and practical measures must be considered.
        \end{itemize}
    \end{block}

    \begin{block}{Real-World Example}
        \textbf{Google Search}: Uses advanced techniques to optimize time and relevancy considering metrics like user engagement and click rates.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Collaborative Problem-Solving - Introduction}
    \begin{block}{Introduction to Search Algorithms in Group Projects}
        Search algorithms are integral to problem-solving in various contexts. When applied to collaborative group projects, they help in efficiently navigating through vast solution spaces, streamlining communication, and enhancing decision-making processes.
    \end{block}
    
    \begin{itemize}
        \item \textbf{Search Algorithms}: Systematic methods to retrieve information or find solutions by exploring possible configurations (e.g., Depth-First Search, Breadth-First Search, A* Algorithm).
        \item \textbf{Collaborative Problem-Solving}: A group process where team members share insights and leverage their diverse expertise to tackle challenges collectively.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Collaborative Problem-Solving - Enhancement of Collaboration}
    \begin{block}{How Search Algorithms Enhance Collaboration}
        \begin{enumerate}
            \item \textbf{Task Allocation}
            \begin{itemize}
                \item Algorithms help determine task distribution based on skills and availability.
                \item \textit{Example}: Greedy algorithm assigns tasks requiring higher expertise to skilled members first.
            \end{itemize}
            
            \item \textbf{Information Retrieval}
            \begin{itemize}
                \item Efficiently sift through databases to locate relevant information.
                \item \textit{Example}: Binary search algorithm finds resources quickly in sorted databases.
            \end{itemize}
            
            \item \textbf{Problem Decomposition}
            \begin{itemize}
                \item Break complex problems into simpler ones for parallel tackling.
                \item \textit{Example}: Different members explore various design parameters using heuristic algorithms.
            \end{itemize}
            
            \item \textbf{Decision-Making}
            \begin{itemize}
                \item The A* algorithm evaluates paths based on cost functions.
                \item \textit{Example}: Optimizing project deadlines by considering milestones and constraints.
            \end{itemize}
        \end{enumerate}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Collaborative Problem-Solving - Example Scenario & Key Points}
    \begin{block}{Example Scenario: Developing a Mobile App}
        \begin{itemize}
            \item \textbf{Task Assignment}: Use search algorithms to allocate programming, design, and market research tasks based on strengths.
            \item \textbf{Resource Search}: Implement A* to identify the best design templates and libraries online.
            \item \textbf{Iterative Feedback}: Utilize iterative search for analyzing user feedback for improvements.
        \end{itemize}
    \end{block}
    
    \begin{block}{Key Points to Emphasize}
        \begin{itemize}
            \item Search algorithms streamline collaboration.
            \item Effective task distribution enhances productivity.
            \item Collaborative tools with search algorithms improve communication and resource sharing.
        \end{itemize}
    \end{block}
    
    \begin{block}{Conclusion}
        The integration of search algorithms optimizes decision-making, encourages efficiency, and fosters innovation in collaborative settings.
    \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Ethical Implications - Introduction}
  \begin{block}{Introduction to Ethical Considerations}
    Search algorithms play a fundamental role in AI by facilitating data retrieval. 
    However, their implementation raises significant ethical concerns that require careful consideration.
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Ethical Implications - Key Issues}
  \begin{enumerate}
    \item \textbf{Bias and Fairness}
      \begin{itemize}
        \item Description: Algorithms may amplify existing biases in data.
        \item Example: Job screening algorithms favoring certain demographics.
      \end{itemize}
    
    \item \textbf{Transparency and Accountability}
      \begin{itemize}
        \item Description: Users must understand algorithmic operations.
        \item Example: Knowing ranking criteria of search results is essential.
      \end{itemize}
    
    \item \textbf{Privacy Concerns}
      \begin{itemize}
        \item Description: Algorithms may expose large amounts of personal data.
        \item Example: Use of personal search history raises consent issues.
      \end{itemize}
    
    \item \textbf{Manipulation and Misinformation}
      \begin{itemize}
        \item Description: Algorithms can distort information visibility.
        \item Example: Sensationalist content prioritization on social media.
      \end{itemize}
    
    \item \textbf{Accessibility}
      \begin{itemize}
        \item Description: Not all users have equal tech access or understanding.
        \item Example: Accessibility neglect may disadvantage those with disabilities.
      \end{itemize}
  \end{enumerate}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Ethical Implications - Promoting Ethics}
  \begin{block}{Promoting Ethical Search Algorithm Implementation}
    \begin{enumerate}
      \item Use diverse and representative data sets to mitigate bias.
      \item Develop algorithms with user feedback for transparency and relevance.
      \item Conduct regular audits for fairness and accountability.
      \item Simplify explanations of algorithms to build user trust.
      \item Implement regulations for ethical practices in development.
    \end{enumerate}
  \end{block}

  \begin{block}{Conclusion}
    Addressing ethical implications is vital for responsible AI development, fostering an equitable digital landscape.
  \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Hands-On Activities - Overview}
    In this slide, we will outline the programming assignments designed to deepen your understanding of search algorithms. 
    Through practical implementation, you will solidify key concepts and learn to apply search algorithms in various contexts.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Hands-On Activities - Learning Objectives}
    \begin{itemize}
        \item Understand the principles behind different search algorithms.
        \item Gain practical experience through coding assignments.
        \item Analyze the performance of different search methods.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Hands-On Activities - Programming Assignments}
    \begin{enumerate}
        \item \textbf{Linear Search Implementation}
            \begin{itemize}
                \item \textbf{Objective}: Implement a simple linear search algorithm.
                \item \textbf{Description}: Create a function that searches for a target value in an array by checking each element one by one.
                \item \textbf{Example Code:}
                \begin{lstlisting}[language=Python]
def linear_search(arr, target):
    for index in range(len(arr)):
        if arr[index] == target:
            return index  # Target found
    return -1  # Target not found
                \end{lstlisting}
                \item \textbf{Key Point}: Linear search has a time complexity of $O(n)$, where $n$ is the number of elements in the array.
            \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Hands-On Activities - Programming Assignments Continued}
    \begin{enumerate}
        \setcounter{enumi}{1}
        \item \textbf{Binary Search Implementation}
            \begin{itemize}
                \item \textbf{Objective}: Implement a binary search algorithm.
                \item \textbf{Description}: Write a function that finds the position of a target value in a sorted array by dividing the search interval in half repeatedly.
                \item \textbf{Example Code:}
                \begin{lstlisting}[language=Python]
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            return mid  # Target found
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1  # Target not found
                \end{lstlisting}
                \item \textbf{Key Point}: Binary search runs in $O(\log n)$ time and requires a sorted array for correct operation.
            \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Hands-On Activities - Programming Assignments Continued}
    \begin{enumerate}
        \setcounter{enumi}{2}
        \item \textbf{Search Algorithm Performance Analysis}
            \begin{itemize}
                \item \textbf{Objective}: Compare the efficiency of linear and binary search.
                \item \textbf{Description}: Write a program that measures the execution time of both search algorithms when searching for the same target in arrays of varying sizes.
                \item \textbf{Illustration}: Create a simple graph to plot execution time against array size.
                \item \textbf{Key Point}: Understanding time complexity helps in choosing the right algorithm based on constraints.
            \end{itemize}
        \item \textbf{BFS and DFS for Graphs}
            \begin{itemize}
                \item \textbf{Objective}: Implement BFS and DFS to traverse graphs.
                \item \textbf{Description}: Create a class-based structure to represent a graph. Implement both BFS and DFS methods to explore nodes.
                \item \textbf{Example Code for BFS:}
                \begin{lstlisting}[language=Python]
from collections import deque

class Graph:
    def __init__(self):
        self.graph = {}

    def add_edge(self, u, v):
        if u not in self.graph:
            self.graph[u] = []
        self.graph[u].append(v)

    def bfs(self, start):
        visited = set()
        queue = deque([start])
        while queue:
            node = queue.popleft()
            if node not in visited:
                visited.add(node)
                print(node)  # Process the node
                queue.extend(self.graph.get(node, []))
                \end{lstlisting}
                \item \textbf{Key Point}: BFS is useful for finding the shortest path in unweighted graphs, while DFS explores as far as possible down one branch before backtracking.
            \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Hands-On Activities - Conclusion}
    Completing these hands-on activities will give you practical exposure to search algorithms—highlighting their implementations, performance analysis, and applications in real-world scenarios. Remember to focus on both understanding the theory and the practical aspects of these algorithms. Happy coding!
\end{frame}

\begin{frame}[fragile]
    \frametitle{Conclusion and Summary - Overview}
    \begin{block}{Overview of Search Algorithms}
        Search algorithms are essential computational techniques used to retrieve information from data structures. They allow for efficient data processing in various applications, from databases to artificial intelligence.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Conclusion and Summary - Types of Search Algorithms}
    \begin{enumerate}
        \item \textbf{Linear Search}
            \begin{itemize}
                \item \textbf{Description}: A straightforward method that examines each element in a list sequentially.
                \item \textbf{Time Complexity}: O(n)
                \item \textbf{Example}: Searching for the number 5 in a list: [3, 1, 4, 5, 9, 2].
            \end{itemize}

        \item \textbf{Binary Search}
            \begin{itemize}
                \item \textbf{Description}: Works on sorted arrays; repeatedly divides the search interval in half.
                \item \textbf{Time Complexity}: O(log n)
                \item \textbf{Example}: Finding the number 5 in a sorted list: [1, 2, 3, 4, 5, 6, 7].
            \end{itemize}

        \item \textbf{Depth-First Search (DFS)}
            \begin{itemize}
                \item \textbf{Description}: A graph traversal method that explores as far as possible along each branch before backtracking.
                \item \textbf{Use Cases}: Pathfinding, puzzle solving.
                \item \textbf{Example}: Traversing a maze represented as a graph.
            \end{itemize}

        \item \textbf{Breadth-First Search (BFS)}
            \begin{itemize}
                \item \textbf{Description}: Explores all neighbors at the present depth prior to moving on to nodes at the next depth level.
                \item \textbf{Use Cases}: Shortest path in unweighted graphs.
                \item \textbf{Example}: Finding the shortest route in a city grid.
            \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Conclusion and Summary - Applications and Final Thoughts}
    \begin{block}{Summary of Their Applications}
        \begin{itemize}
            \item \textbf{Linear Search}: Suitable for small or unsorted data sets.
            \item \textbf{Binary Search}: Drastically reduces time needed for searches in large sorted data sets.
            \item \textbf{DFS and BFS}: Pivotal for navigating complex networks and graphs, such as social networks or geographical maps.
        \end{itemize}
    \end{block}

    \begin{block}{Key Concepts to Remember}
        \begin{itemize}
            \item Always consider the data structure type when selecting a search algorithm.
            \item The efficiency of a search algorithm significantly impacts the performance of applications.
            \item Understanding the underlying mechanisms of search algorithms enhances problem-solving skills in programming.
        \end{itemize}
    \end{block}
    
    \begin{block}{Final Thoughts}
        Search algorithms form the basis of numerous software applications. Mastery of these concepts enables efficient data handling and forms a foundational skill for further exploration in computer science.
    \end{block}
\end{frame}


\end{document}