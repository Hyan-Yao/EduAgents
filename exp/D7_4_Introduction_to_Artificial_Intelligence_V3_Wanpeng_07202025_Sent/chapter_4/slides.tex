\documentclass[aspectratio=169]{beamer}

% Theme and Color Setup
\usetheme{Madrid}
\usecolortheme{whale}
\useinnertheme{rectangles}
\useoutertheme{miniframes}

% Additional Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}
\usetikzlibrary{positioning}
\usepackage{hyperref}

% Custom Colors
\definecolor{myblue}{RGB}{31, 73, 125}
\definecolor{mygray}{RGB}{100, 100, 100}
\definecolor{mygreen}{RGB}{0, 128, 0}
\definecolor{myorange}{RGB}{230, 126, 34}
\definecolor{mycodebackground}{RGB}{245, 245, 245}

% Set Theme Colors
\setbeamercolor{structure}{fg=myblue}
\setbeamercolor{frametitle}{fg=white, bg=myblue}
\setbeamercolor{title}{fg=myblue}
\setbeamercolor{section in toc}{fg=myblue}
\setbeamercolor{item projected}{fg=white, bg=myblue}
\setbeamercolor{block title}{bg=myblue!20, fg=myblue}
\setbeamercolor{block body}{bg=myblue!10}
\setbeamercolor{alerted text}{fg=myorange}

% Set Fonts
\setbeamerfont{title}{size=\Large, series=\bfseries}
\setbeamerfont{frametitle}{size=\large, series=\bfseries}
\setbeamerfont{caption}{size=\small}
\setbeamerfont{footnote}{size=\tiny}

% Custom Commands
\newcommand{\hilight}[1]{\colorbox{myorange!30}{#1}}
\newcommand{\concept}[1]{\textcolor{myblue}{\textbf{#1}}}

% Title Page Information
\title[Week 4: CSPs]{Week 4: Constraint Satisfaction Problems}
\author[J. Smith]{John Smith, Ph.D.}
\institute[University Name]{
  Department of Computer Science\\
  University Name\\
  Email: email@university.edu\\
  Website: www.university.edu
}
\date{\today}

% Document Start
\begin{document}

\frame{\titlepage}

\begin{frame}[fragile]
    \titlepage
\end{frame}

\begin{frame}[fragile]
    \frametitle{Introduction to Constraint Satisfaction Problems}
    \begin{block}{What are Constraint Satisfaction Problems (CSPs)?}
        Constraint Satisfaction Problems are mathematical problems defined by a set of objects whose state must satisfy several constraints and conditions. In essence, CSPs focus on how to assign values from specific domains to a set of variables under certain restrictions.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Concepts}
    \begin{itemize}
        \item {\bf Variables}: Entities that need to be assigned values. 
        For example, in a scheduling problem, the variables could be timeslots for tasks.
        
        \item {\bf Domains}: The possible values that each variable can take. 
        For instance, if a variable represents a day of the week, its domain might be $\{Monday, Tuesday, \ldots, Sunday\}$.
        
        \item {\bf Constraints}: Restrictions or conditions that specify allowable combinations of values for the variables. 
        An example constraint might be that two meetings cannot occur at the same time.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Relevance in Artificial Intelligence}
    CSPs play a fundamental role in various AI applications, including:
    \begin{itemize}
        \item {\bf Scheduling}: Assigning time slots for meetings or classes while considering constraints such as availability.
        \item {\bf Resource Allocation}: Distributing resources across tasks where some tasks may conflict.
        \item {\bf Puzzle Solving}: Challenges such as Sudoku or the 8-Queens Problem can be viewed as CSPs, where the goal is to fill a grid while meeting specific criteria.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Example: Sudoku as a CSP}
    \begin{itemize}
        \item {\bf Variables}: Each cell in the Sudoku grid.
        \item {\bf Domains}: Numbers 1 through 9.
        \item {\bf Constraints}: Each number must appear once per row, column, and 3x3 sub-grid.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Points to Emphasize}
    \begin{itemize}
        \item CSPs involve finding a solution that satisfies all given constraints.
        \item They are significant in automating problem-solving in AI.
        \item Many algorithms (like Backtracking, Forward Checking) are specialized for solving CSPs efficiently.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Conclusion}
    Understanding CSPs is crucial in the development of intelligent systems. They provide a framework that can be utilized in diverse applications within AI and beyond.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Learning Objectives}
    By the end of this chapter, students should be able to:
    \begin{itemize}
        \item Define CSPs.
        \item Identify their components.
        \item Recognize their applications within the field of artificial intelligence.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Definition of CSPs}
    \begin{block}{What is a Constraint Satisfaction Problem (CSP)?}
        A \textbf{Constraint Satisfaction Problem (CSP)} is a mathematical problem defined as a set of objects whose state must satisfy several constraints and limitations. 
        CSPs are widely used in fields such as artificial intelligence, operations research, and computer science to model problems that require specific configurations or solutions.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Components of CSPs}
    \begin{itemize}
        \item \textbf{Variables:} 
        \begin{itemize}
            \item A variable represents an unknown quantity we want to determine.
            \item Example: In a scheduling problem, variables could represent time slots for meetings (e.g., \texttt{Meeting1}, \texttt{Meeting2}).
        \end{itemize}
        
        \item \textbf{Domains:} 
        \begin{itemize}
            \item Each variable has a domain, the set of possible values it can take.
            \item Example: For the variable \texttt{Meeting1}, the domain might be \{9 AM, 10 AM, 11 AM\}.
        \end{itemize}
        
        \item \textbf{Constraints:} 
        \begin{itemize}
            \item Constraints define relationships between variables and restrict the values they can simultaneously take.
            \item Example: If \texttt{Meeting1} and \texttt{Meeting2} cannot occur at the same time, then \texttt{Meeting1} $\neq$ \texttt{Meeting2}.
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Formal Definition of CSPs}
    A CSP can be formally defined as a triple \((X, D, C)\):
    \begin{itemize}
        \item \(X\): A set of variables \(\{X_1, X_2, \ldots, X_n\}\)
        \item \(D\): A set of domains \(\{D_1, D_2, \ldots, D_n\}\), where each \(D_i\) is the domain of variable \(X_i\)
        \item \(C\): A set of constraints that define allowable combinations of values for the variables.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Applications of CSPs}
    \begin{itemize}
        \item CSPs provide a structured way to represent problems where specific criteria must be met.
        \item They are applicable in various real-world scenarios, such as:
        \begin{itemize}
            \item Scheduling
            \item Resource allocation
            \item Puzzle solving (e.g., Sudoku)
            \item Configuration problems
        \end{itemize}
        \item Understanding the components of CSPs is crucial for designing algorithms that can find solutions efficiently.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Example Scenario: Sudoku Puzzle}
    \begin{itemize}
        \item \textbf{Variables:} Each cell in the Sudoku grid (i.e., \(X_{i,j}\) for a cell in row \(i\), column \(j\)).
        \item \textbf{Domains:} Each cell can take values from 1 to 9 (i.e., \(D_{i,j} = \{1, 2, 3, \dots, 9\}\)).
        \item \textbf{Constraints:} Each number must be unique in its row, column, and 3x3 grid (i.e., constraints specify \(X_{i,j} \neq X_{k,m}\) where applicable).
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Key Components of CSPs - Overview}
  \begin{block}{Learning Objectives}
    \begin{itemize}
      \item Understand the main components of Constraint Satisfaction Problems (CSPs).
      \item Identify variables, domains, and constraints and their roles in CSPs.
      \item Apply these concepts to illustrate simple examples.
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Key Components of CSPs - Variables}
  \begin{block}{1. Variables}
    \begin{itemize}
      \item \textbf{Definition:} Variables are the unknowns we want to assign values to in a CSP. Each variable can take on a value from its defined domain.
      \item \textbf{Example:} In a Sudoku puzzle, each cell in the grid is a variable.
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Key Components of CSPs - Domains and Constraints}
  \begin{block}{2. Domains}
    \begin{itemize}
      \item \textbf{Definition:} The domain of a variable is the set of possible values that the variable can take.
      \item \textbf{Example:} For a variable representing a day of the week, the domain might be $\{$Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday$\}$.
    \end{itemize}
  \end{block}
  
  \begin{block}{3. Constraints}
    \begin{itemize}
      \item \textbf{Definition:} Constraints are rules that define allowable combinations of values for variables. Constraints restrict the values that variables can simultaneously take.
      \item \textbf{Examples:}
        \begin{itemize}
          \item In map coloring, a constraint might state that two adjacent regions cannot be the same color.
          \item In a scheduling problem, a constraint could be that a person cannot be in two places at once.
        \end{itemize}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Key Components of CSPs - Summary and Examples}
  \begin{block}{Key Points to Emphasize}
    \begin{itemize}
      \item \textbf{Interdependence:} The interactions between variables, domains, and constraints define the structure of a CSP.
      \item \textbf{Problem Solving:} Effective solutions for CSPs involve systematically searching through combinations of variable assignments while respecting constraints.
      \item \textbf{Applications:} CSPs have real-world applications in scheduling, resource allocation, and puzzle solving across various fields.
    \end{itemize}
  \end{block}
  
  \begin{block}{Example Problem Setup}
    \begin{itemize}
      \item \textbf{Variables:} X1, X2 (representing tasks).
      \item \textbf{Domains:} D(X1) = $\{1, 2, 3\}$, D(X2) = $\{1, 2\}$.
      \item \textbf{Constraints:} X1 $\neq$ X2 (both tasks must be assigned different times).
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Key Components of CSPs - Conclusion}
  \begin{block}{Summary}
    The essence of a CSP lies in its components: variables stand as placeholders, domains offer a scope of potential solutions, and constraints enforce the rules that navigate the solution space. Understanding these elements is crucial for addressing diverse CSPs effectively.
  \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Examples of CSPs - Introduction}
    \begin{block}{What is a CSP?}
        A Constraint Satisfaction Problem (CSP) is a scenario where a solution must satisfy a number of constraints or conditions. We will explore notable examples of CSPs in various contexts.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Examples of CSPs - Map Coloring}
    \begin{block}{1. Map Coloring}
        \begin{itemize}
            \item \textbf{Concept}: Color adjacent regions of a map differently.
            \item \textbf{Example}:
            \begin{itemize}
                \item Problem: Color a map of Australia with 3 colors.
                \item Variables: States (e.g., Queensland, New South Wales).
                \item Domains: Set of colors (e.g., Red, Green, Blue).
                \item Constraints: No two adjacent states share the same color.
            \end{itemize}
            \item \textbf{Key Point}: The Four Color Theorem states four colors suffice for any map.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Examples of CSPs - Sudoku and Scheduling Problems}
    \begin{block}{2. Sudoku}
        \begin{itemize}
            \item \textbf{Concept}: Fill a 9x9 grid with numbers from 1 to 9.
            \item \textbf{Example}:
            \begin{itemize}
                \item Problem: Complete a Sudoku grid.
                \item Variables: Each empty cell.
                \item Domains: Numbers 1 through 9.
                \item Constraints: Each number appears only once per row, column, 3x3 box.
            \end{itemize}
            \item \textbf{Key Point}: Solving involves systematic assignment while adhering to constraints.
        \end{itemize}
    \end{block}

    \begin{block}{3. Scheduling Problems}
        \begin{itemize}
            \item \textbf{Concept}: Allocate time slots while satisfying constraints.
            \item \textbf{Example}:
            \begin{itemize}
                \item Problem: Schedule classes for a high school.
                \item Variables: Each class that needs scheduling.
                \item Domains: Available time slots.
                \item Constraints: No overlapping classes for the same student or teacher.
            \end{itemize}
            \item \textbf{Key Point}: Efficient scheduling involves adhering to constraints, showing practical applications of CSPs.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Types of Constraints - Overview}
    \begin{block}{Learning Objectives}
        \begin{itemize}
            \item Understand the different types of constraints used in Constraint Satisfaction Problems (CSPs).
            \item Identify the characteristics and applications of unary, binary, and global constraints.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Types of Constraints - Unary and Binary}
    \begin{block}{Unary Constraints}
        \begin{itemize}
            \item \textbf{Definition:} Involves a single variable, restricting the allowed values.
            \item \textbf{Example:} If \( X \) is a person's age, a constraint could be \( X \geq 18 \).
            \item \textbf{Key Point:} Used to enforce domain limits on individual variables.
        \end{itemize}
    \end{block}

    \begin{block}{Binary Constraints}
        \begin{itemize}
            \item \textbf{Definition:} Relates two variables and restricts the combinations of their values.
            \item \textbf{Example:} For seats assigned to Alice \( (X) \) and Bob \( (Y) \), a constraint could be \( X \neq Y \).
            \item \textbf{Key Point:} Important in scheduling and assignment problems.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Types of Constraints - Global}
    \begin{block}{Global Constraints}
        \begin{itemize}
            \item \textbf{Definition:} Involve larger subsets of variables, encapsulating complex relationships.
            \item \textbf{Example:} The \textbf{AllDifferent} constraint ensures each variable in a set has a unique value (e.g., Sudoku).
            \item \textbf{Key Point:} Simplifies problem formulation and enhances search efficiency.
        \end{itemize}
    \end{block}

    \begin{block}{Summary}
        \begin{itemize}
            \item Unary, binary, and global constraints are crucial in CSPs.
            \item Understanding these constraints guides efficient algorithm design and problem-solving strategies.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Illustrative Formulas}
    \begin{block}{Examples of Constraints}
        \begin{itemize}
            \item \textbf{Unary Constraint Example:} \( D(X) = \{ x | x \geq 18 \} \)
            \item \textbf{Binary Constraint Example:} \( (X, Y) \rightarrow X \neq Y \)
            \item \textbf{Global Constraint Example:} If \( C \) is a set of variables, then \textbf{AllDifferent(C)} is given by:
            \begin{equation}
                \forall x_1, x_2 \in C, x_1 \neq x_2
            \end{equation}
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Graphical Representation of CSPs}
    \begin{block}{Learning Objectives}
        \begin{itemize}
            \item Understand what a constraint graph is in the context of Constraint Satisfaction Problems (CSPs).
            \item Recognize the significance of graphical representations for visualizing and solving CSPs.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Concept of a Constraint Graph}
    A \textbf{constraint graph} is a visual representation used to depict the variables and constraints of a CSP:
    \begin{itemize}
        \item \textbf{Nodes}: Each node represents a variable in the CSP.
        \item \textbf{Edges}: Each edge connects variables that are directly constrained by a specific relationship (constraint).
    \end{itemize}
    \begin{block}{Example}
        Consider three variables \(X_1, X_2, X_3\) with the following constraints:
        \begin{itemize}
            \item \(X_1\) and \(X_2\) are constrained (e.g., \(X_1 + X_2 \leq 10\)).
            \item \(X_2\) and \(X_3\) are constrained (e.g., \(X_2 + X_3 = 5\)).
        \end{itemize}
        Graphically, it can be represented as:
        \begin{equation*}
            \text{   } X_1 \\
            \text{    |} \\
            \text{    |} \\
            \text{   } X_2 \text{ -- } X_3
        \end{equation*}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Significance of Graphical Representation}
    \begin{itemize}
        \item \textbf{Simplifies Complexity}: Helps in simplifying the complexity of problems, especially with many variables and constraints.
        \item \textbf{Facilitates Understanding}: Visualizing relationships highlights how variables interact, aiding comprehension.
        \item \textbf{Enables Algorithm Design}: Algorithms like graph-based search can leverage this representation for efficiency.
    \end{itemize}
    \begin{block}{Example Application}
        Consider the \textbf{map-coloring problem}:
        \begin{itemize}
            \item \textbf{Variables}: Each region on the map.
            \item \textbf{Domains}: The colors available for each region, e.g., \{Red, Green, Blue\}.
            \item \textbf{Constraints}: Two adjacent regions cannot have the same color.
        \end{itemize}
        The constraint graph illustrates connections between regions, making it easier to apply algorithms ensuring no adjacent regions share colors.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Points and Summary}
    \begin{itemize}
        \item A well-constructed constraint graph can reveal insights into the structure of the CSP, such as clique structures and variable independence.
        \item Understanding the graph can determine when backtracking or arc-consistency algorithms are appropriate.
        \item Encourages systematic and visual analysis for variable assignment respecting all constraints.
    \end{itemize}
    Graphical representations not only clarify relationships but also enhance our ability to solve complex problems efficiently using visual strategies and algorithms.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Backtracking Search - Introduction}
    \begin{block}{What is Backtracking?}
        Backtracking is a systematic method for solving Constraint Satisfaction Problems (CSPs) by incrementally building candidates to solutions and abandoning candidates as soon as they cannot lead to a valid complete solution.
    \end{block}
    
    \begin{itemize}
        \item Effective exploration of the search space of solutions.
        \item Particularly useful in cases where constraints limit possibilities.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Backtracking Search - Key Concepts}
    \begin{itemize}
        \item \textbf{CSP Definition}: A CSP consists of a set of variables, each with a domain of possible values, and constraints on the assignments.
        \item \textbf{State Space Tree}: Visualizes the process where each node represents a partial assignment of variables.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Backtracking Search - How It Works}
    \begin{enumerate}
        \item \textbf{Choose a Variable}: Select an unassigned variable using heuristics.
        \item \textbf{Assign Values}: Iterate over its possible values from the domain.
        \item \textbf{Check Constraints}:
            \begin{itemize}
                \item If \textbf{valid}, proceed to the next variable.
                \item If \textbf{no valid assignments remain}, backtrack to the previous variable.
            \end{itemize}
        \item \textbf{Base Case}: Continue until all variables are assigned valid values or all possibilities are exhausted.
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Backtracking Search - Example: 4-Queens Problem}
    \begin{block}{Problem Definition}
        Place four queens on a 4x4 chessboard so that no two queens threaten each other.
    \end{block}
    \begin{itemize}
        \item \textbf{Variables}: {Q1, Q2, Q3, Q4}
        \item \textbf{Domains}: Possible positions {1, 2, 3, 4}.
        \item \textbf{Constraints}: No two queens in the same row or diagonal.
    \end{itemize}
    
    \begin{block}{Backtracking Process}
        \begin{enumerate}
            \item Start with Q1 in column 1.
            \item Place Q2 in column 2, check for validity.
            \item No valid placements for Q3, backtrack to Q2, try column 3.
            \item Continue until all queens are placed or backtrack further.
        \end{enumerate}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Backtracking Search - Key Points}
    \begin{itemize}
        \item \textbf{Efficiency:} Enhanced using techniques like constraint propagation and heuristics (e.g., Minimum Remaining Values).
        \item \textbf{Applications:} Solving puzzles, scheduling, resource allocation, etc.
    \end{itemize}
    
    \begin{block}{Pseudocode Example}
        \begin{lstlisting}
function backtrack(assignment):
    if isComplete(assignment):
        return assignment
    variable = selectUnassignedVariable(assignment)
    for value in orderDomainValues(variable):
        if isConsistent(assignment, variable, value):
            assignment[variable] = value
            result = backtrack(assignment)
            if result != failure:
                return result
            assignment[variable] = unset
    return failure
        \end{lstlisting}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Backtracking Search - Conclusion}
    Backtracking is a fundamental method for effectively tackling CSPs by systematically exploring the search space and pruning options.

    \begin{itemize}
        \item Understand its operation to solve complex problems efficiently within computer science and operations research.
    \end{itemize}
    
    \begin{block}{Next Steps}
        Consider how backtracking's behavior changes with different types of constraints and variable ordering strategies before moving on to heuristic methods.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Heuristic Methods - Overview}
    \begin{block}{Introduction}
        Heuristic methods are strategic approaches used to solve Constraint Satisfaction Problems (CSPs) more efficiently than standard backtracking search.
    \end{block}
    
    \begin{itemize}
        \item Focus on guiding the search process
        \item Narrow down potential solutions quickly
        \item Key heuristics introduced:
        \begin{itemize}
            \item Minimum Remaining Value (MRV)
            \item Degree Heuristic
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Heuristic Methods - Minimum Remaining Value (MRV)}
    \begin{block}{Definition}
        MRV, or "Fail First," selects the variable with the fewest legal values left in its domain.
    \end{block}
    
    \begin{itemize}
        \item Fewer options = more constraint → solving it early can help prevent getting stuck.
    \end{itemize}
    
    \begin{block}{Example: Sudoku}
        Consider the following Sudoku layout:
        \begin{center}
            \begin{tabular}{ |c|c|c|c| }
                \hline
                  &   & 5 &   \\
                \hline
                1 & 6 &   & 7 \\
                \hline
                  &   &   &   \\
                \hline
                4 &   & 3 &   \\
                \hline
            \end{tabular}
        \end{center}
        \begin{itemize}
            \item Empty cell has domain size = 2 (options 2 or 3)
            \item MRV suggests filling this cell first.
        \end{itemize}
    \end{block}

    \begin{block}{Key Takeaway}
        Using MRV reduces the branching factor and leads to faster solutions.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Heuristic Methods - Degree Heuristic}
    \begin{block}{Definition}
        The Degree Heuristic prioritizes variables involved in the highest number of constraints with unassigned variables.
    \end{block}

    \begin{itemize}
        \item Focuses on selecting variables that influence the maximum number of decisions.
    \end{itemize}

    \begin{block}{Example: CSP Interconnections}
        If you have the following connections among variables:
        \begin{itemize}
            \item **A:** connects to B and C
            \item **B:** connects to A and D
            \item **C:** connects to A
            \item **D:** connects to B
        \end{itemize}
        \begin{itemize}
            \item Prefer assigning values to A first due to its higher degree of connection.
        \end{itemize}
    \end{block}
    
    \begin{block}{Key Takeaway}
        The Degree Heuristic minimizes future conflicts by addressing the most interconnected variables first.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Summary and Next Steps}
    \begin{block}{Summary of Heuristic Methods}
        \begin{itemize}
            \item Heuristics improve search efficiency for complex CSPs.
            \item Combining MRV and Degree Heuristic can enhance effectiveness.
            \item Applications include scheduling, resource allocation, and puzzle-solving.
        \end{itemize}
    \end{block}
    
    \begin{block}{Next Steps}
        Understanding these heuristics sets the foundation for exploring advanced optimization strategies, such as \textbf{Forward Checking}.
    \end{block}
    
    \begin{block}{Conclusion}
        Applying these methods allows us to intelligently search for solutions, reducing unnecessary computations.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Forward Checking - Overview}
    \begin{block}{Definition}
        \textbf{Forward Checking} is a technique used in solving Constraint Satisfaction Problems (CSPs) to enhance efficiency by looking ahead and pruning the search space during the assignment of variables.
    \end{block}
    
    \begin{itemize}
        \item \textbf{Variables:} Entities that need value assignments.
        \item \textbf{Domains:} Possible value ranges for each variable.
        \item \textbf{Constraints:} Limitations on the value combinations for variables.
    \end{itemize}
    
    \begin{block}{Role in Pruning}
        Forward checking eliminates invalid values from the domains of unassigned variables whenever a variable is assigned a value, thus effectively reducing the search space.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Forward Checking - Example}
    \textbf{Consider the following CSP:}
    
    \begin{itemize}
        \item \textbf{Variables:} \(X_1, X_2, X_3\)
        \item \textbf{Domains:}
        \begin{itemize}
            \item \(D(X_1) = \{1, 2\}\)
            \item \(D(X_2) = \{1, 2, 3\}\)
            \item \(D(X_3) = \{1, 2\}\)
        \end{itemize}
        \item \textbf{Constraints:}
        \begin{itemize}
            \item \(X_1 \neq X_2\)
            \item \(X_2 \neq X_3\)
        \end{itemize}
    \end{itemize}

    \vspace{0.5cm}
    
    \textbf{Steps with Forward Checking:}
    \begin{enumerate}
        \item Assign \(X_1 = 1\).
        \item Check \(X_2\) and \(X_3\): valid values remain unchanged.
        \item Assign \(X_2 = 1\): \(X_1\) conflict detected.
        \begin{itemize}
            \item Update \(D(X_2) = \{2, 3\}\).
        \end{itemize}
        \item Assign \(X_2 = 2\): update \(D(X_3) = \{1\}\) with valid options.
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Forward Checking - Key Points and Code}
    
    \begin{block}{Key Insights}
        \begin{itemize}
            \item Reduces the search space by early elimination of unusable values.
            \item Streamlines the search process, minimizing backtracking.
            \item Especially beneficial in highly constrained CSP scenarios.
        \end{itemize}
    \end{block}

    \vspace{0.5cm}
    
    \textbf{Code Snippet:}
    \begin{lstlisting}[language=Python]
def forward_checking(assignment, constraints):
    for var in assignment:
        for (neighbor, val) in constraints[var]:
            if val in constraints[neighbor]:
                constraints[neighbor].remove(val)  # Prune the domain
    return constraints
    \end{lstlisting}

    \begin{block}{Conclusion}
        Incorporating forward checking in CSP algorithms not only improves efficiency but also enhances the effectiveness of constraint satisfaction techniques.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Constraint Propagation - Learning Objectives}
    \begin{itemize}
        \item Understand the concept of constraint propagation in Constraint Satisfaction Problems (CSPs).
        \item Grasp the significance of Arc Consistency and how it aids in solving CSPs effectively.
        \item Explore the impact of propagation methods on the search space and solution efficiency.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{What is Constraint Propagation?}
    \begin{block}{Definition}
        Constraint Propagation refers to techniques used in CSPs to systematically narrow down possible values of variables based on constraints. The goal is to infer variable values and detect inconsistencies early.
    \end{block}
    
    \begin{itemize}
        \item \textbf{Constraint Satisfaction Problem (CSP):} Defined by a set of variables, a domain for each variable, and constraints that restrict combinations of assignments.
        \item \textbf{Consistency Levels:}
            \begin{itemize}
                \item Node Consistency: Each variable satisfies its unary constraints.
                \item Arc Consistency: Every value of a variable has a consistent value in a connected variable.
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Arc Consistency (AC)}
    \begin{block}{Definition}
        Arc Consistency checks if for every value of a variable, there exists a valid value of another variable connected by a constraint. Inconsistencies lead to the removal of values from the variable's domain.
    \end{block}
    
    \begin{example}
        Consider Variables A and B:
        \begin{itemize}
            \item \textbf{Domains:} A = \{1, 2\}, B = \{2, 3\}
            \item \textbf{Constraint:} A < B
        \end{itemize}
    \end{example}

    \begin{block}{Process}
        1. Check the arc from A to B:
        \begin{itemize}
            \item For A = 1: B can be 2 or 3 → \textbf{Consistent}
            \item For A = 2: B has no valid options → \textbf{Inconsistent}
        \end{itemize}
        \textbf{Result:} Remove 2 from A's domain. New Domain of A: A = \{1\}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Impact of Constraint Propagation}
    \begin{itemize}
        \item \textbf{Increased Efficiency:} Reducing domains before search allows algorithms to explore fewer possibilities, resulting in faster solutions.
        \item \textbf{Early Detection of Inconsistencies:} Helps identify unsolvable conditions early, saving computational resources.
    \end{itemize}
    
    \begin{block}{Key Points}
        \begin{itemize}
            \item Constraint propagation is a powerful tool for simplifying CSPs by reducing the domain of variables.
            \item It leads to quicker solutions and effectively structures the search space.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Mathematical Representation of Arc Consistency}
    Given an arc (X, Y), where X and Y are variables, the arc is consistent if:
    \begin{equation}
        \forall x \in \text{domain}(X), \exists y \in \text{domain}(Y) \text{ such that } (x, y) \in \text{constraint}(X, Y)
    \end{equation}
    If inconsistency is found, values are removed from the domain of X or Y.

    \begin{block}{Conclusion}
        This foundational concept sets the stage for exploring various CSP-solving algorithms in the next section.
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Examples of CSP Algorithms}
    
    \textbf{Learning Objectives:}
    \begin{itemize}
        \item Understand the key algorithms used to solve Constraint Satisfaction Problems (CSPs)
        \item Recognize the differences between Backtracking and Arc Consistency algorithms
        \item Appreciate the strengths and limitations of each algorithm
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Backtracking Algorithm}
    
    \begin{block}{Overview}
        Backtracking is a depth-first search algorithm that incrementally builds candidates for solutions and abandons candidates ("backtracks") as soon as it determines that they cannot lead to a valid solution.
    \end{block}
    
    \textbf{How It Works:}
    \begin{enumerate}
        \item Choose a variable and assign a value from its domain.
        \item Check if this assignment is consistent with the constraints.
        \item If consistent, move to the next variable.
        \item If inconsistent, backtrack to the previous step, change the variable’s assignment, and repeat.
        \item If all variables are assigned successfully, a solution is found; if not, declare no solution exists.
    \end{enumerate}

    \textbf{Example:}
    Color a map with three colors such that no adjacent areas have the same color using Backtracking.
\end{frame}

\begin{frame}
    \frametitle{Backtracking Algorithm - Example Continued}
    
    \begin{itemize}
        \item Step 1: Assign color Red to Area 1.
        \item Step 2: Check constraints on adjacent areas (e.g., Area 2 and Area 3).
        \item Step 3: If Area 2 cannot be colored Red, try another color (e.g., Blue) and repeat.
    \end{itemize}
    
    \textbf{Key Points:}
    \begin{itemize}
        \item Completeness: Guaranteed to find a solution if one exists, given enough time and memory.
        \item Time Complexity: Exponential in the worst case.
        \item Useful for small, structured problems.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Arc Consistency Algorithm}
    
    \begin{block}{Overview}
        Arc Consistency is a form of constraint propagation that reduces the search space by ensuring that for every value of a variable, there exists a consistent value in the connected variable.
    \end{block}
    
    \textbf{How It Works:}
    \begin{enumerate}
        \item For each variable, check all arcs to ensure at least one valid value exists in the domain of the connected variable.
        \item Remove values from the domain that do not allow for any consistent values in connected variables.
        \item Repeat this process until no values can be removed or until the problem is inconsistent.
    \end{enumerate}
\end{frame}

\begin{frame}
    \frametitle{Arc Consistency Algorithm - Example}
    
    \textbf{Example:}
    Consider two variables X (with values $\{1, 2\}$) and Y (with values $\{2, 3\}$) with a constraint that X must be less than Y.
    
    \begin{itemize}
        \item Check (X=1) - Valid (Y can be $\{2,3\}$).
        \item Check (X=2) - Invalid (No value for Y).
        \item Remove 2 from X's domain.
        \item X’s domain is now $\{1\}$, and Y remains $\{2, 3\}$.
    \end{itemize}
    
    \textbf{Key Points:}
    \begin{itemize}
        \item Reduces search space significantly before search begins.
        \item Works well with complex constraints by simplifying the problem.
        \item Not a complete method; often combined with Backtracking.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Summary}
    
    Both Backtracking and Arc Consistency are foundational algorithms for solving CSPs, each with its approach and impact on the search process. Understanding these algorithms aids in solving CSPs and enhances problem-solving strategies in broader applications such as scheduling and planning.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Additional Resources}
    
    \textbf{Code Snippet:}
    \begin{lstlisting}[language=Python]
def backtracking(csp, assignment):
    if len(assignment) == len(csp.variables):
        return assignment  # Found a solution
    variable = select_unassigned_variable(csp, assignment)
    for value in order_domain_values(variable, assignment):
        if is_consistent(variable, value, assignment, csp):
            assignment[variable] = value
            result = backtracking(csp, assignment)
            if result is not None:
                return result
            del assignment[variable]  # Backtrack
    return None  # No solution found
    \end{lstlisting}

    This slide equips you with the foundational algorithms to tackle CSPs, setting the stage for practical applications discussed in the next slide.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Applications of CSPs - Introduction}
    \begin{block}{What are CSPs?}
        Constraint Satisfaction Problems (CSPs) involve finding a solution to a set of constraints that impose restrictions on the values assigned to variables.
    \end{block}
    
    \begin{block}{Importance of CSPs}
        CSPs play a crucial role in optimal decision-making across various fields and in many practical scenarios.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Applications of CSPs - Key Applications}
    \begin{enumerate}
        \item \textbf{Scheduling}
        \item \textbf{Resource Allocation}
        \item \textbf{AI Planning}
    \end{enumerate}
    
    \begin{block}{Flexibility of CSPs}
        CSPs can model a vast range of practical problems, making them applicable in multiple fields, from logistics to computer networking.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Applications of CSPs - Examples}
    \begin{itemize}
        \item \textbf{Scheduling: University Course Scheduling}
        \begin{itemize}
            \item \textit{Variables:} Courses, time slots, classrooms, instructors.
            \item \textit{Constraints:} 
            \begin{itemize}
                \item No room can host more than one course at the same time.
                \item Instructors must be available for their assigned courses.
                \item Students should not have overlapping courses in their schedules.
            \end{itemize}
        \end{itemize}
        
        \item \textbf{Resource Allocation: Job Assignment}
        \begin{itemize}
            \item \textit{Variables:} Jobs, workers.
            \item \textit{Constraints:}
            \begin{itemize}
                \item Each job must be assigned to exactly one worker.
                \item Workers should not exceed their maximum working hours.
                \item Some jobs require specific skills that only certain workers possess.
            \end{itemize}
            \item \textit{Mathematical Representation:} Define a cost function $f(x)$ that minimizes the total cost while meeting constraints.
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Applications of CSPs - Conclusion}
    \begin{block}{Summary}
        CSPs provide a robust framework for solving complexities across various domains. Understanding their applications reveals their importance in creating efficient, automated systems in our everyday lives.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Comparison of CSP Solving Techniques - Overview}
    \begin{block}{Overview}
        Constraint Satisfaction Problems (CSPs) require finding values for variables that meet specific constraints. This slide compares various techniques for solving CSPs, emphasizing their strengths and weaknesses.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Comparison Table of CSP Solving Techniques}
    \centering
    \begin{tabular}{|l|l|l|l|}
        \hline
        \textbf{Technique} & \textbf{Description} & \textbf{Strengths} & \textbf{Weaknesses} \\
        \hline
        Backtracking Search & A systematic method to explore possible variable assignments. & 
        - Simple to implement \\ - Complete (if a solution exists) & 
        - Can be slow due to exhaustive search \\ - Inefficient in large spaces \\
        \hline
        Forward Checking & A look-ahead technique that checks constraints as variables are assigned. & 
        - Reduces search space \\ - Prevents inconsistent assignments early & 
        - Requires additional memory \\ - Can still result in backtracking \\
        \hline
        Arc-Consistency (AC-3) & An algorithm that reduces search space by enforcing arc consistency. & 
        - Reduces the number of values before search \\ - Often fast in practice & 
        - Can be computationally expensive for large variables \\ - Limited to binary constraints \\
        \hline
        Constraint Propagation & Propagates constraints to reduce the domains of variables incrementally. & 
        - Significant reduction of search space \\ - Works well with specific problem structures & 
        - May require complex handling of constraint networks \\ - Can be computationally intense \\
        \hline
        Local Search (e.g. Min-Conflicts) & Iterative improvement on a current solution by making local adjustments. & 
        - Fast and efficient for large problems \\ - Useful for satisfaction rather than optimization & 
        - May get stuck in local optima \\ - Not guaranteed to find a solution \\
        \hline
        Integer Programming (IP) & Formulates CSPs as mathematical models to be solved using optimization techniques. & 
        - Powerful for complex problems \\ - Well-studied algorithms available & 
        - Can be complex to set up \\ - Lacks scalability for large CSPs \\
        \hline
        Heuristic Search (e.g. A*) & Uses heuristics to guide the search process for more intelligent exploration. & 
        - Can be faster than exhaustive methods \\ - Works well with designed heuristics & 
        - Performance highly dependent on the choice of heuristic \\ - May still require significant computation \\
        \hline
    \end{tabular}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Points and Context}
    \begin{itemize}
        \item \textbf{Trade-offs:} Each method has specific contexts in which it excels and fails. Understanding these will help select the right approach for a given CSP.
        \item \textbf{Hybrid Approaches:} Combining techniques can often yield better results, especially for complex or large-scale problems.
        \item \textbf{Performance Measurement:} Always consider the scalability and efficiency of a technique based on the problem size and the structure of constraints.
    \end{itemize}

    \begin{block}{Example Context}
        For instance, in scheduling tasks, backtracking may initially seem appealing, but using forward checking can dramatically speed up the process by pruning invalid options early on.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Challenges in Solving CSPs - Introduction}
    \begin{block}{Introduction to CSP Challenges}
        Constraint Satisfaction Problems (CSPs) are essential in AI and computer science. The primary goal is to assign values to variables such that all constraints are met. Challenges arise, especially as CSPs have diverse applications, like scheduling and puzzle-solving (e.g., Sudoku). The following slides will outline common challenges and potential solutions.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Challenges in Solving CSPs - Common Challenges}
    \begin{enumerate}
        \item[1.] \textbf{Complexity and Scale}
            \begin{itemize}
                \item \textbf{Explanation:} The search space increases exponentially with more variables and constraints.
                \item \textbf{Illustration:} A graph representation becomes denser as more variables are added.
            \end{itemize}
        
        \item[2.] \textbf{Inherent NP-Hardness}
            \begin{itemize}
                \item \textbf{Explanation:} Many CSPs cannot be solved quickly (within polynomial time).
                \item \textbf{Example:} Even a standard 9x9 Sudoku puzzle has immense possibilities.
            \end{itemize}
        
        \item[3.] \textbf{Constraint Propagation}
            \begin{itemize}
                \item \textbf{Explanation:} Techniques like Arc Consistency can reduce search space but are computationally intensive.
                \item \textbf{Key Concept:} Arc Consistency ensures that every value in a variable corresponds consistently with neighboring variables.
            \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Challenges in Solving CSPs - Potential Solutions}
    \begin{enumerate}
        \item[1.] \textbf{Backtracking with Heuristics}
            \begin{itemize}
                \item \textbf{Description:} Incremental solution building with backtracking when constraints are violated.
                \item \textbf{Example:} Using Minimum Remaining Values (MRV) in Sudoku prioritizes cells with fewer options.
            \end{itemize}
        
        \item[2.] \textbf{Local Search Algorithms}
            \begin{itemize}
                \item \textbf{Description:} Algorithms (e.g., Min-Conflicts) start with a complete assignment and minimize constraint violations iteratively.
                \item \textbf{Illustration:} In graph-coloring, change only conflicting vertex colors instead of all combinations.
            \end{itemize}
        
        \item[3.] \textbf{Decomposition}
            \begin{itemize}
                \item \textbf{Description:} Break large CSPs into simpler subproblems, especially when subsets are independent.
                \item \textbf{Example:} For scheduling, solve independent tasks separately.
            \end{itemize}
        
        \item[4.] \textbf{Use of Constraint Solvers}
            \begin{itemize}
                \item \textbf{Description:} Leverage established solver tools (e.g., MiniZinc) for optimized solutions.
                \item \textbf{Key Point:} Understanding various solver strengths helps in selecting suitable tools for specific CSPs.
            \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Challenges in Solving CSPs - Conclusion}
    \begin{block}{Conclusion}
        While CSPs present significant challenges due to their complexity and NP-hard characteristics, leveraging strategies such as heuristics, local search, decomposition, and efficient constraint solvers can greatly improve problem-solving capabilities. Understanding these challenges and techniques is essential for effective problem resolution in practical applications.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Case Study: Sudoku as a CSP}

    \begin{block}{Understanding Sudoku as a CSP}
        A Constraint Satisfaction Problem (CSP) is defined by:
        \begin{itemize}
            \item \textbf{Variables:} Elements that need to be assigned values.
            \item \textbf{Domains:} Possible values for each variable.
            \item \textbf{Constraints:} Rules that limit the values that the variables can take.
        \end{itemize}
    \end{block}

    \begin{block}{Sudoku Basics}
        A standard Sudoku puzzle consists of a 9x9 grid.
        \begin{itemize}
            \item The grid is divided into nine 3x3 subgrids (boxes).
            \item The objective is to fill the grid such that:
            \begin{enumerate}
                \item Each row contains digits 1-9 without repetition.
                \item Each column contains digits 1-9 without repetition.
                \item Each 3x3 box contains digits 1-9 without repetition.
            \end{enumerate}
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Representing Sudoku as a CSP}

    \begin{enumerate}
        \item \textbf{Variables:} Each cell in the Sudoku grid is a variable. For a 9x9 grid, there are 81 variables.
        
        \item \textbf{Domains:} Each variable (cell) can take values from the domain {1, 2, 3, 4, 5, 6, 7, 8, 9} depending on the placed digits.
        
        \item \textbf{Constraints:} 
        \begin{itemize}
            \item \textbf{Row Constraints:} No two variables in the same row can have the same value.
            \item \textbf{Column Constraints:} No two variables in the same column can have the same value.
            \item \textbf{Box Constraints:} No two variables in the same 3x3 subgrid can have the same value.
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Example of a Sudoku CSP}

    Consider the following partial Sudoku grid:

    \[
    \begin{array}{|c|c|c|c|c|c|c|c|c|}
    \hline
    5 & 3 &   &   & 7 &   &   &   &   \\
    \hline
    6 &   &   & 1 & 9 & 5 &   &   &   \\
    \hline
      & 9 & 8 &   &   &   &   & 6 &   \\
    \hline
    8 &   &   &   & 6 &   &   &   & 3 \\
    \hline
    4 &   &   & 8 &   & 3 &   &   & 1 \\
    \hline
    7 &   &   &   & 2 &   &   &   & 6 \\
    \hline
      & 6 &   &   &   &   & 2 & 8 &   \\
    \hline
       &   &   & 4 & 1 & 9 &   &   & 5 \\
    \hline
       &   &   &   & 8 &   &   & 7 & 9 \\
    \hline
    \end{array}
    \]

    \begin{itemize}
        \item \textbf{Variables:} Each empty cell can be seen as a variable \( x_{i,j} \).
        \item \textbf{Domains:} For instance, \( x_{0,2} \) can take any value from 1-9, obeying constraints based on digits in the same row, column, and box.
        \item \textbf{Constraints:} \( x_{0,2} \) cannot be 5 or 3 due to values already in Row 0.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Solving Methods for Sudoku CSP}

    \begin{enumerate}
        \item \textbf{Backtracking:}
        \begin{itemize}
            \item A depth-first search algorithm that assigns values to variables one at a time.
            \item Backtracks when a constraint is violated.
        \end{itemize}

        \item \textbf{Constraint Propagation:}
        \begin{itemize}
            \item Techniques such as Arc Consistency can reduce the search space.
            \item Eliminates values from domains of variables that cannot be consistent with current assignments.
        \end{itemize}

        \item \textbf{Heuristic Techniques:}
        \begin{itemize}
            \item \textbf{Minimum Remaining Values (MRV):} Choose the variable with the fewest legal values next.
            \item \textbf{Forward Checking:} After assigning a value to a variable, eliminate inconsistent values from the domains of connected variables.
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Points to Emphasize}

    \begin{itemize}
        \item A Sudoku puzzle is an excellent example of a CSP due to its clearly defined variables, domains, and constraints.
        \item Understanding CSPs provides insight into various algorithmic approaches for solving not just Sudoku, but many real-world problems.
        \item Methods like backtracking, constraint propagation, and heuristics are common strategies for solving CSPs efficiently.
    \end{itemize}
    
    \begin{block}{Next Steps}
        Consider revising the understanding of these concepts before moving on to the conclusion. Ensure solid comprehension of how CSPs function in both theoretical and practical applications!
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Conclusion and Learning Objectives Review - Part 1}
    \begin{block}{Key Takeaways from Constraint Satisfaction Problems (CSPs)}
        \begin{enumerate}
            \item \textbf{Definition \& Basics:}
            \begin{itemize}
                \item A Constraint Satisfaction Problem (CSP) is defined by a set of variables, each with a domain of possible values, and a set of constraints that restrict the values the variables can simultaneously take.
                \item Example: Sudoku, where the grid variables must satisfy constraints to avoid duplicate numbers in rows, columns, or regions.
            \end{itemize}

            \item \textbf{CSP Components:}
            \begin{itemize}
                \item \textbf{Variables:} Elements we want to assign values to (e.g., cells in Sudoku).
                \item \textbf{Domains:} Possible values for each variable (e.g., {1, 2, 3, \ldots, 9} for Sudoku).
                \item \textbf{Constraints:} Conditions that must be met (e.g., no two cells in the same row can have the same value).
            \end{itemize}

            \item \textbf{Importance of CSPs in AI:}
            \begin{itemize}
                \item CSPs provide a structured approach to solving complex problems in robotics, scheduling, and resource allocation.
                \item They facilitate systematic search methods and heuristics for efficient solutions.
            \end{itemize}
        \end{enumerate}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Conclusion and Learning Objectives Review - Part 2}
    \begin{block}{Learning Objectives Review}
        \begin{enumerate}
            \item \textbf{Identify CSP Elements:}
            \begin{itemize}
                \item Understand how to define variables, domains, and constraints in a CSP.
                \item Example: For scheduling problems, identify tasks (variables), possible times (domains), and restrictions (constraints).
            \end{itemize}
            
            \item \textbf{Solve CSPs Using Algorithms:}
            \begin{itemize}
                \item Learn algorithms like Backtracking, Forward Checking, and Constraint Propagation for solving CSPs.
                \item \textbf{Code Snippet:}
                \begin{lstlisting}[language=Python]
def backtrack(assignment):
    if is_complete(assignment):
        return assignment
    variable = select_unassigned_variable(assignment)
    for value in order_domain_values(variable):
        if is_consistent(variable, value, assignment):
            assignment[variable] = value
            result = backtrack(assignment)
            if result:
                return result
            del assignment[variable]
    return None
                \end{lstlisting}
            \end{itemize}

            \item \textbf{Apply CSPs to Real-World Problems:}
            \begin{itemize}
                \item Model real-world scenarios as CSPs using techniques discussed previously.
                \item Analyze trade-offs among different solving methods based on constraints and complexity.
            \end{itemize}
        \end{enumerate}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Conclusion and Learning Objectives Review - Part 3}
    \begin{block}{Emphasizing Key Points}
        \begin{itemize}
            \item CSPs are crucial in AI for organized problem-solving.
            \item Mastering CSP concepts enhances the ability to tackle applied problems.
            \item Practical understanding is fostered through modeling and solving examples such as Sudoku, scheduling, or AI in games.
        \end{itemize}
    \end{block}
    \begin{block}{Final Note}
        By revisiting and understanding these key aspects, students will enhance their capacity to engage with and apply constraint satisfaction techniques in artificial intelligence and related fields.
    \end{block}
\end{frame}


\end{document}