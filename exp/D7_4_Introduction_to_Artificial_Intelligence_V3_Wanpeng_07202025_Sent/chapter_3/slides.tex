\documentclass[aspectratio=169]{beamer}

% Theme and Color Setup
\usetheme{Madrid}
\usecolortheme{whale}
\useinnertheme{rectangles}
\useoutertheme{miniframes}

% Additional Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}
\usetikzlibrary{positioning}
\usepackage{hyperref}

% Custom Colors
\definecolor{myblue}{RGB}{31, 73, 125}
\definecolor{mygray}{RGB}{100, 100, 100}
\definecolor{mygreen}{RGB}{0, 128, 0}
\definecolor{myorange}{RGB}{230, 126, 34}
\definecolor{mycodebackground}{RGB}{245, 245, 245}

% Set Theme Colors
\setbeamercolor{structure}{fg=myblue}
\setbeamercolor{frametitle}{fg=white, bg=myblue}
\setbeamercolor{title}{fg=myblue}
\setbeamercolor{section in toc}{fg=myblue}
\setbeamercolor{item projected}{fg=white, bg=myblue}
\setbeamercolor{block title}{bg=myblue!20, fg=myblue}
\setbeamercolor{block body}{bg=myblue!10}
\setbeamercolor{alerted text}{fg=myorange}

% Set Fonts
\setbeamerfont{title}{size=\Large, series=\bfseries}
\setbeamerfont{frametitle}{size=\large, series=\bfseries}
\setbeamerfont{caption}{size=\small}
\setbeamerfont{footnote}{size=\tiny}

% Document Start
\begin{document}

\frame{\titlepage}

\begin{frame}[fragile]
    \frametitle{Introduction to Search Algorithms}
    \begin{block}{Overview}
        Search algorithms are vital in Artificial Intelligence (AI) as they allow machines to efficiently explore problem spaces to find solutions. 
    \end{block}
    \begin{itemize}
        \item Definition: Systematic methods for navigating data structures or problem spaces.
        \item Importance:
        \begin{itemize}
            \item Problem Solving
            \item Automation
            \item Complexity Management
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Concepts in Search Algorithms}
    \begin{enumerate}
        \item \textbf{Search Space}
        \begin{itemize}
            \item Set of all configurations where a solution may be found.
            \item Example: Solving a maze involves traversing all paths.
        \end{itemize}

        \item \textbf{Nodes and States}
        \begin{itemize}
            \item Node: Represents a possible state in the search.
            \item Example: In tic-tac-toe, each arrangement of X's and O's is a node.
        \end{itemize}

        \item \textbf{Branches}
        \begin{itemize}
            \item Possible actions leading to new nodes.
            \item Example: Player moves in a game represent branches to new states.
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Types of Search Algorithms}
    \begin{enumerate}
        \item \textbf{Uninformed (Blind) Search}
            \begin{itemize}
                \item No additional information about goal's location.
                \item Examples: Breadth-First Search, Depth-First Search.
                \item \textbf{Use:} Suitable for undefined search spaces.
            \end{itemize}

        \item \textbf{Informed (Heuristic) Search}
            \begin{itemize}
                \item Utilizes problem-specific knowledge for efficiency.
                \item Examples: A* Search, Greedy Search.
                \item \textbf{Use:} Effective for complex problems with large spaces.
            \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Example: Breadth-First Search (BFS)}
    \begin{block}{BFS Algorithm}
    \begin{lstlisting}[language=Python]
def bfs(graph, start):
    visited = set()
    queue = [start]

    while queue:
        vertex = queue.pop(0)
        if vertex not in visited:
            visited.add(vertex)
            queue.extend(set(graph[vertex]) - visited)

    return visited
    \end{lstlisting}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Points to Emphasize}
    \begin{itemize}
        \item \textbf{Efficiency:} Search algorithms reduce solution time.
        \item \textbf{Application:} Used in robotics, game development, web search.
        \item \textbf{Scalability:} Understand algorithms to effectively handle larger tasks.
    \end{itemize}
    
    \begin{block}{Conclusion}
        Understanding search algorithms equips us with tools for building intelligent systems capable of navigating data and making informed decisions.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Uninformed Search Strategies - Introduction}
    \begin{block}{Definition}
        Uninformed search strategies, also known as blind search strategies, are algorithms that explore the search space without any domain-specific knowledge. They rely solely on the problem formulation and systematically search through the state space to find a solution.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Uninformed Search Strategies - Key Characteristics}
    \begin{itemize}
        \item \textbf{No Additional Information:} Uninformed searches do not utilize heuristics or any extra information about the state space.
        \item \textbf{Systematic Exploration:} These algorithms explore states systematically, either breadth-first or depth-first.
        \item \textbf{Guaranteed Completeness:} Certain uninformed search algorithms guarantee finding a solution if one exists.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Common Uninformed Search Strategies}
    \begin{enumerate}
        \item \textbf{Breadth-First Search (BFS)}: Expands all nodes at the present depth level before moving deeper.
        \item \textbf{Depth-First Search (DFS)}: Explores as far as possible down one branch before backing up.
        \item \textbf{Uniform Cost Search:} Expands the node with the lowest path cost to find the least costly path to the goal.
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{When to Use Uninformed Search}
    \begin{itemize}
        \item \textbf{Limited Knowledge:} When minimal or no information is available regarding the domain.
        \item \textbf{Simple Problems:} Applicable for problems with a small search space.
        \item \textbf{Complete Solutions Necessary:} Essential when a solution must be found regardless of the efficiency involved.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Examples of Uninformed Search}
    \begin{itemize}
        \item \textbf{Example 1:} Maze navigation using BFS ensures the shortest path is explored layer by layer.
        \item \textbf{Example 2:} Depth-First Search can be applied to solve puzzles like the Tower of Hanoi by exploring each configuration deeply until reaching the goal.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Points and Conclusion}
    \begin{itemize}
        \item Uninformed search strategies are fundamental and lay the groundwork for understanding more advanced methods.
        \item They may be inefficient in large state spaces, leading to high computational costs.
        \item Their effectiveness heavily depends on the structure of the search space.
    \end{itemize}
    \begin{block}{Concluding Thought}
        Uninformed search strategies form the backbone of search algorithms in artificial intelligence. Understanding these strategies equips us for exploring more complex search methods in future discussions.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Breadth-First Search (BFS) - Overview}
    \begin{block}{Learning Objectives}
        \begin{itemize}
            \item Understand the mechanics of the Breadth-First Search algorithm.
            \item Identify various use cases and applications of BFS in real-world scenarios.
            \item Compare BFS with other search strategies.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Breadth-First Search (BFS) - Mechanics}
    \begin{block}{What is Breadth-First Search?}
        Breadth-First Search (BFS) is a graph traversal algorithm that explores nodes and edges of a graph or tree data structure.
    \end{block}
    
    \begin{block}{How BFS Works:}
        \begin{enumerate}
            \item \textbf{Initialization:}
            \begin{itemize}
                \item Choose a source node to begin traversal.
                \item Use a queue to track nodes to be explored.
                \item Maintain a visited set to prevent cycles.
            \end{itemize}
            
            \item \textbf{Traversal:}
            \begin{itemize}
                \item Enqueue the initial node and mark it as visited.
                \item While the queue is not empty:
                    \begin{itemize}
                        \item Dequeue a node.
                        \item Process the node (display or store).
                        \item Enqueue all unvisited adjacent nodes, marking them as visited.
                    \end{itemize}
            \end{itemize}
        \end{enumerate}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{BFS Algorithm Steps and Characteristics}
    \begin{block}{BFS Algorithm Steps}
    \begin{lstlisting}
BFS(graph, start_node):
  initialize empty queue Q
  mark start_node as visited
  enqueue start_node into Q

  while Q is not empty:
    current_node = dequeue Q
    process current_node

    for each neighbor in current_node.adjacents:
      if neighbor is not visited:
        mark neighbor as visited
        enqueue neighbor into Q
    \end{lstlisting}
    \end{block}

    \begin{block}{Characteristics of BFS}
        \begin{itemize}
            \item \textbf{Time Complexity:} $O(V + E)$ (where $V$ is number of vertices and $E$ is number of edges).
            \item \textbf{Space Complexity:} $O(V)$ (stores all nodes in queue and visited set).
            \item \textbf{Optimal for Unweighted Graphs:} Finds shortest path in unweighted graphs.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Use Cases and Example of BFS}
    \begin{block}{Use Cases of BFS}
        \begin{enumerate}
            \item Finding Shortest Paths
            \item Web Crawlers
            \item Social Networks
            \item Network Broadcasting
        \end{enumerate}
    \end{block}

    \begin{block}{BFS Example}
        Starting from node A in the graph:
        
        \begin{center}
            \includegraphics[width=0.25\textwidth]{graph-example.png} % Placeholder for graph image
        \end{center}
        
        \textbf{Traversal sequence:} A → B → C → D → E → F
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Depth-First Search (DFS) - Overview}
    \begin{block}{Definition}
        Depth-First Search (DFS) is a fundamental algorithm used in artificial intelligence and computer science for traversing or searching tree and graph data structures.
    \end{block}
    \begin{itemize}
        \item Explores as far as possible along each branch before backing up.
        \item Ideal for problems requiring complete exploration of a solution space.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Depth-First Search (DFS) - Mechanics}
    \begin{enumerate}
        \item \textbf{Initialization:} Start from the root node or a selected node.
        \item \textbf{Traversal:} 
            \begin{itemize}
                \item Use a stack (explicit or recursive).
                \item Push the initial node onto the stack.
                \item While the stack is not empty:
                    \begin{itemize}
                        \item Pop top node.
                        \item Check if it is the goal node.
                        \item If not, mark as visited and push all unvisited neighbors onto the stack.
                    \end{itemize}
            \end{itemize}
        \item \textbf{Backtracking:} Explore other branches upon reaching a dead end.
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Depth-First Search (DFS) - Pseudocode and Key Points}
    \begin{block}{Pseudocode}
        \begin{lstlisting}[language=Python]
DFS(graph, start_node):
    create an empty stack
    create a set to keep track of visited nodes
    push start_node onto stack

    while stack is not empty:
        node = pop from stack
        if node is goal:
            return node
        if node is not visited:
            mark node as visited
            for each neighbor in graph[node]:
                if neighbor is not visited:
                    push neighbor onto stack
        \end{lstlisting}
    \end{block}
    
    \begin{itemize}
        \item DFS can be implemented using recursion and explicit stacks.
        \item Suitable for tasks like puzzle solving and topological sorting.
        \item Understanding DFS and BFS helps to choose the right algorithm based on needs.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Comparison of BFS and DFS}
    \begin{block}{Learning Objectives}
        \begin{itemize}
            \item Understand and differentiate between Breadth-First Search (BFS) and Depth-First Search (DFS).
            \item Analyze the strengths and weaknesses of each algorithm in various scenarios.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Overview of BFS and DFS}
    \begin{block}{Definitions}
        \begin{itemize}
            \item \textbf{BFS (Breadth-First Search)}: Explores all neighbors at the present depth prior to moving on to nodes at the next depth level. Usually implemented using a queue.
            \item \textbf{DFS (Depth-First Search)}: Explores as far down a branch of a graph or tree as possible before backtracking. Typically implemented using a stack (or recursion).
        \end{itemize}
    \end{block}
    \begin{block}{Use Cases}
        \begin{itemize}
            \item \textbf{BFS Example}: In a social network graph, BFS can find the shortest connection path between two users.
            \item \textbf{DFS Example}: In a maze, DFS can be used to explore all possible paths until it finds the exit.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Strengths and Weaknesses of BFS and DFS}
    \begin{tabular}{|l|c|c|}
        \hline
        \textbf{Criteria} & \textbf{BFS} & \textbf{DFS} \\
        \hline
        Memory Usage & High (stores all nodes at the current level) & Low (stores only the current path in memory) \\
        Performance & Slower in deep graphs (O(V + E)) & Fast in deep graphs (O(V + E)) \\
        Completeness & Always finds the shortest path in unweighted graphs & May not find the shortest path \\
        Applications & Shortest path searches, peer-to-peer networks & Solving puzzles, scheduling problems \\
        Implementation Complexity & Generally easier to implement & Can be more complex due to recursive nature \\
        \hline
    \end{tabular}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Code Snippet: BFS vs. DFS in Python}
    \begin{block}{BFS Implementation}
    \begin{lstlisting}[language=Python]
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    
    while queue:
        vertex = queue.popleft()
        if vertex not in visited:
            visited.add(vertex)
            queue.extend(graph[vertex] - visited)
    return visited
    \end{lstlisting}
    \end{block}
    \begin{block}{DFS Implementation}
    \begin{lstlisting}[language=Python]
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    
    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
    return visited
    \end{lstlisting}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Conclusion}
    \begin{block}{Key Takeaways}
        \begin{itemize}
            \item Choose BFS for shortest paths in unweighted graphs.
            \item Use DFS for exhaustive searches or pathfinding where costs differ.
            \item Consider memory and performance trade-offs based on specific use cases.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Informed Search Strategies - Introduction}
    \begin{block}{Introduction}
        Informed search strategies leverage additional information, often in the form of heuristics, to guide the search process toward the goal more efficiently than uninformed methods. 
    \end{block}
    
    \begin{itemize}
        \item Aim: Reduce search space and improve search algorithm effectiveness.
        \item Contrast: Informed vs. Uninformed methods.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Informed Search Strategies - Key Differences}
    \begin{block}{Uninformed Search}
        \begin{itemize}
            \item **Definition**: Explore the search space without additional knowledge.
            \item **Examples**: Breadth-First Search (BFS), Depth-First Search (DFS).
            \item **Characteristics**: Guarantee completeness and optimality but may be inefficient.
        \end{itemize}
    \end{block}
    
    \begin{block}{Informed Search}
        \begin{itemize}
            \item **Definition**: Use heuristic knowledge to prioritize promising paths.
            \item **Examples**: A*, Greedy Best-First Search.
            \item **Characteristics**: Reduce the number of nodes explored, increasing the solution speed.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Informed Search Strategies - Heuristics}
    \begin{block}{Understanding Heuristics}
        \begin{itemize}
            \item **Definition**: A function estimating the cost of the cheapest path from a node to the goal.
            \item **Importance**: Guides the search process for faster solutions.
        \end{itemize}
    \end{block}

    \begin{equation}
        h(n) = \sqrt{(x_{\text{goal}} - x_{n})^2 + (y_{\text{goal}} - y_{n})^2}
    \end{equation}

    \begin{block}{Key Points to Emphasize}
        \begin{itemize}
            \item **Efficiency**: Informed algorithms are generally more efficient.
            \item **Optimality**: Not all guarantee optimal solutions without consistent heuristics.
            \item **Adaptability**: Heuristics can be tailored for specific domains.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Heuristic Search - Understanding Heuristics}
    
    \begin{block}{Definition}
        Heuristics are problem-solving strategies that use readily accessible information and common sense to make educated guesses.
    \end{block}
    
    In search algorithms, heuristics guide the search process towards the most promising paths, making them significantly more efficient than uninformed methods.
\end{frame}

\begin{frame}[fragile]
    \frametitle{Heuristic Search - Importance}
    
    \begin{itemize}
        \item \textbf{Efficiency}: Reduces search space and computation time.
        \item \textbf{Optimality}: Helps find good enough solutions quickly, often sufficient in real-world scenarios.
        \item \textbf{Applicability}: Tailored to specific problems, making them flexible across various fields, such as AI and operations research.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Heuristic Search - Examples of Heuristics}
    
    \begin{enumerate}
        \item \textbf{Manhattan Distance}
            \begin{equation}
                h(n) = |x_2 - x_1| + |y_2 - y_1|
            \end{equation}
            Suitable for grid-based pathfinding.
            
        \item \textbf{Greedy Best-First Search}
            Evaluates nodes based on a heuristic to choose the most promising one.
            
        \item \textbf{Domain-Specific Heuristics}
            Example: Chess heuristics evaluate positions based on piece development and control.
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Heuristic Search - Key Points}
    
    \begin{itemize}
        \item Heuristics are context-dependent methods tailored for specific problems.
        \item Efficiency gained often comes at the cost of completeness and optimality.
        \item Understanding the problem characteristics is crucial for effective heuristic development.
    \end{itemize}

    With these concepts in mind, we can now explore specific heuristic search algorithms, such as the A* algorithm, which intelligently combines the heuristic estimate with the cost to reach the current node.
\end{frame}

\begin{frame}[fragile]
    \frametitle{A* Search Algorithm - Overview}
    \begin{itemize}
        \item The A* Search Algorithm is a powerful pathfinding and graph traversal algorithm.
        \item Used in fields such as:
        \begin{itemize}
            \item Artificial Intelligence
            \item Robotics
            \item Geographic Information Systems
        \end{itemize}
        \item A* finds the most efficient path from a starting node to a target node by exploring paths based on estimated costs.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{A* Search Algorithm - Key Concepts}
    \begin{enumerate}
        \item \textbf{Graph Representation:}
        \begin{itemize}
            \item Operates on nodes (states) and edges (costs).
        \end{itemize}
        
        \item \textbf{Cost Function:}
        \begin{equation}
        f(n) = g(n) + h(n)
        \end{equation}
        where:
        \begin{itemize}
            \item $g(n)$: cost to reach node $n$ from the start.
            \item $h(n)$: heuristic estimate of cost from $n$ to goal.
        \end{itemize}
        
        \item \textbf{Heuristic Function:}
        \begin{itemize}
            \item Should be \textbf{Admissible} and \textbf{Consistent}.
            \item Example consistency condition:
            \begin{equation}
            h(n) \leq c(n, n') + h(n')
            \end{equation}
        \end{itemize}
        
        \item \textbf{Open and Closed Sets:}
        \begin{itemize}
            \item \textbf{Open Set}: Nodes to be evaluated.
            \item \textbf{Closed Set}: Nodes already evaluated.
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{A* Search Algorithm - Steps and Applications}
    \begin{block}{Algorithm Steps}
        \begin{enumerate}
            \item Initialize the Open Set with the start node.
            \item Repeat until the Open Set is empty:
            \begin{itemize}
                \item Pick node $n$ with lowest $f(n)$.
                \item If $n$ is the goal, reconstruct and return the path.
                \item Move $n$ to the Closed Set.
                \item For each neighbor $n'$ of $n$:
                \begin{itemize}
                    \item Ignore if $n'$ is in the Closed Set.
                    \item Calculate $g(n')$ and $h(n')$.
                    \item Add $n'$ to the Open Set if not already present.
                    \item Update $f(n')$ if this path is better.
                \end{itemize}
            \end{itemize}
        \end{enumerate}
    \end{block}

    \begin{block}{Applications}
        \begin{itemize}
            \item Robotics: Pathfinding for navigation.
            \item Gaming: AI movement in games.
            \item Network Routing: Optimizing data paths.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Other Heuristic Algorithms}
    \begin{block}{Learning Objectives}
        \begin{itemize}
            \item Understand the concept and function of heuristic algorithms in search optimization.
            \item Explore the Greedy Best-First Search algorithm and its applications.
            \item Compare different heuristic strategies and their effectiveness.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Introduction to Heuristic Algorithms}
    Heuristic algorithms are problem-solving methods that utilize practical approaches to find solutions more efficiently than traditional methods, particularly in large search spaces. They leverage rules of thumb or "educated guesses" to guide the search process instead of exhaustively evaluating every possible option.
\end{frame}

\begin{frame}
    \frametitle{Greedy Best-First Search}
    One of the notable heuristic algorithms is \textbf{Greedy Best-First Search} (GBFS). This algorithm focuses on exploring the most promising paths by selecting nodes based on a heuristic function \( h(n) \), which estimates the cost from the current node to the goal.
    
    \begin{block}{Key Characteristics}
        \begin{itemize}
            \item \textbf{Strategy}: Always expands the node that seems closest to the goal based on the heuristic.
            \item \textbf{Speed}: Generally faster than uninformed search methods as it minimizes the number of nodes explored.
            \item \textbf{Optimality}: Does not guarantee finding the least-cost path and may lead to local optima.
        \end{itemize}
    \end{block}
    
    \begin{block}{Pseudocode for GBFS}
        \begin{lstlisting}[language=Python]
function GreedyBestFirstSearch(start, goal):
    openSet := priorityQueue() // nodes to be explored
    openSet.add(start)
    while openSet is not empty:
        current := openSet.pop() // node with lowest h(n)
        if current is goal:
            return reconstructPath(current)
        for each neighbor of current:
            if neighbor is not visited:
                neighbor.parent := current
                openSet.add(neighbor)
        \end{lstlisting}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Example Scenario}
    Consider a navigation app that needs to guide users from point A to point B on a map. The app can utilize Greedy Best-First Search, treating each city location as a node. The heuristic function could estimate the distance to the destination using a straight-line distance (Euclidean distance).

    \begin{block}{Illustration of GBFS}
        \begin{itemize}
            \item Start at Point A.
            \item Expand neighboring cities based on their distance to Point B.
            \item Continue until Point B is reached.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Key Points to Emphasize}
    \begin{itemize}
        \item \textbf{Efficiency vs. Optimality}: GBFS is efficient but may not provide the optimal solution.
        \item \textbf{Heuristic Importance}: The choice of heuristic function significantly impacts the effectiveness of the GBFS algorithm.
        \item \textbf{Comparison with A*}: Unlike A* Search, which balances the cost to reach the node and the estimated cost to the goal, GBFS focuses exclusively on the estimated cost.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Conclusion}
    Understanding and applying various heuristic algorithms like Greedy Best-First Search can greatly enhance the efficiency of search processes. While they may not always yield the best solution, their speed and effectiveness in diverse applications render them invaluable tools for solving complex problems.
    
    \begin{block}{Next Steps}
        Explore real-world applications of search algorithms and their impact on decision-making processes.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Real-World Applications of Search Algorithms - Introduction}
    \begin{block}{Introduction}
        Search algorithms are essential tools in computer science that enable efficient data retrieval and problem-solving. They are applied in various real-world scenarios across different domains, impacting the way we access information and make decisions.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Real-World Applications of Search Algorithms - Key Applications}
    \begin{itemize}
        \item \textbf{Web Search Engines}
            \begin{itemize}
                \item Search engines like Google utilize sophisticated search algorithms (e.g., PageRank) to retrieve and rank web pages.
                \item \textit{Example:} Searching for "best pizza places nearby" results in the most relevant pages.
            \end{itemize}
        
        \item \textbf{Social Media and Network Recommendation}
            \begin{itemize}
                \item Social networks use algorithms to recommend connections based on user behavior.
                \item \textit{Example:} Facebook suggests friends by analyzing interactions and profile data.
            \end{itemize}
        
        \item \textbf{Pathfinding in Navigation Systems}
            \begin{itemize}
                \item GPS applications use search algorithms like A* or Dijkstra's to determine the best route.
                \item \textit{Example:} A navigation app calculates the most efficient path considering traffic.
            \end{itemize}
        
        \item \textbf{Game Development}
            \begin{itemize}
                \item Games implement search algorithms for AI movement and strategies.
                \item \textit{Example:} The Minimax algorithm evaluates moves in strategy games.
            \end{itemize}
        
        \item \textbf{Database Search}
            \begin{itemize}
                \item Databases utilize algorithms like binary search for efficient retrieval.
                \item \textit{Example:} Optimizing speed in querying large datasets.
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Real-World Applications of Search Algorithms - Conclusion}
    \begin{block}{Key Points to Emphasize}
        \begin{itemize}
            \item \textbf{Efficiency:} Search algorithms improve data retrieval and decision-making speed.
            \item \textbf{Versatility:} Applicable across various fields, enhancing everyday tasks.
            \item \textbf{Continuous Development:} Ongoing advancements shape our interaction with technology.
        \end{itemize}
    \end{block}
    
    \begin{block}{Additional Resources}
        Consider exploring search algorithms such as A*, Dijkstra’s, and others through platforms like LeetCode or GeeksforGeeks for practical understanding and implementation.
    \end{block}

    \begin{block}{Conclusion}
        Understanding search algorithms is crucial for navigating the complexities of modern information systems, showcasing their significance in daily life and professional domains.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Performance Metrics - Introduction}
    \begin{block}{Introduction to Performance Metrics}
        When evaluating search algorithms, it's essential to understand how effectively they operate in terms of both time and space. Performance metrics help us compare different algorithms and make informed choices based on our specific requirements.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Performance Metrics - Key Metrics}
    \begin{enumerate}
        \item \textbf{Time Complexity}
            \begin{itemize}
                \item Assesses the time an algorithm takes relative to input size.
                \item Expressed using Big O notation (e.g., O(n), O(log n)).
                \item \textbf{Example:} A linear search algorithm with a time complexity of O(n) checks each element in a list.
            \end{itemize}
        \item \textbf{Space Complexity}
            \begin{itemize}
                \item Measures the amount of memory required by an algorithm relative to input size.
                \item Also expressed using Big O notation.
                \item \textbf{Example:} A recursive Fibonacci function has a space complexity of O(n).
            \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Performance Metrics - Summary Table}
    \begin{block}{Example of Search Algorithms}
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Algorithm} & \textbf{Time Complexity} & \textbf{Space Complexity} \\
        \hline
        Linear Search & O(n) & O(1) \\
        Binary Search & O(log n) & O(1) \\
        Depth-First Search & O(b\textsuperscript{d}) & O(b), where b is branching factor, d is depth \\
        Breadth-First Search & O(b\textsuperscript{d}) & O(b\textsuperscript{d}) \\
        \hline
    \end{tabular}
    \end{block}
    
    \begin{block}{Conclusion}
        Evaluating search algorithms via performance metrics—time and space—is critical for selecting the most suitable algorithm for a given problem.
    \end{block}
\end{frame}

\begin{frame}
    \titlepage
\end{frame}

\begin{frame}
    \frametitle{Overview}
    \begin{itemize}
        \item Implementing three fundamental search algorithms in Python:
        \begin{itemize}
            \item Breadth-First Search (BFS)
            \item Depth-First Search (DFS)
            \item A* Algorithm
        \end{itemize}
        \item Key components, structure, pseudocode, and Python implementation will be covered.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{1. Breadth-First Search (BFS)}
    \begin{block}{Concept}
        BFS explores nodes level by level using a queue. Ideal for finding the shortest path in unweighted graphs.
    \end{block}
    \begin{itemize}
        \item Completeness: Guaranteed solution if exists.
        \item Time Complexity: $O(V + E)$, where $V$ is vertices and $E$ is edges.
    \end{itemize}
    \begin{block}{Pseudocode}
    \begin{lstlisting}
function BFS(start_node):
    create a queue Q
    mark start_node as visited
    Q.enqueue(start_node)
    
    while not Q.is_empty():
        current_node = Q.dequeue()
        process(current_node)
        
        for each neighbor in current_node.neighbors:
            if not neighbor.is_visited():
                mark neighbor as visited
                Q.enqueue(neighbor)
    \end{lstlisting}
    \end{block}
    \begin{block}{Python Implementation}
    \begin{lstlisting}[language=Python]
from collections import deque

def bfs(graph, start_node):
    visited = set()
    queue = deque([start_node])

    while queue:
        current_node = queue.popleft()
        print(current_node)  # Process the current node
        visited.add(current_node)

        for neighbor in graph[current_node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    \end{lstlisting}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{2. Depth-First Search (DFS)}
    \begin{block}{Concept}
        DFS explores as far down one branch as possible before backtracking. Can be implemented using recursion or an explicit stack.
    \end{block}
    \begin{itemize}
        \item Completeness: Not guaranteed in infinite graphs.
        \item Time Complexity: $O(V + E)$.
    \end{itemize}
    \begin{block}{Pseudocode}
    \begin{lstlisting}
function DFS(node):
    mark node as visited
    process(node)
    
    for each neighbor in node.neighbors:
        if not neighbor.is_visited():
            DFS(neighbor)
    \end{lstlisting}
    \end{block}
    \begin{block}{Python Implementation (Recursive)}
    \begin{lstlisting}[language=Python]
def dfs(graph, node, visited=set()):
    visited.add(node)
    print(node)  # Process the current node

    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
    \end{lstlisting}
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{3. A* Algorithm}
    \begin{block}{Concept}
        A* is an informed search algorithm that uses heuristics to guide exploration. It calculates the cost from the start node plus an estimate of the cost to the goal node.
    \end{block}
    \begin{itemize}
        \item Completeness: Yes, with an appropriate heuristic.
        \item Time Complexity: Generally exponential, depending on the heuristic.
    \end{itemize}
    \begin{block}{Pseudocode}
    \begin{lstlisting}
function A_star(start_node, goal_node):
    create open_set (priority queue)
    add start_node to open_set
    create came_from dict
    set g_score[start_node] = 0
    set f_score[start_node] = heuristic(start_node, goal_node)
    
    while open_set is not empty:
        current = node in open_set with lowest f_score
        if current == goal_node:
            return reconstruct_path(came_from, current)
        
        open_set.remove(current)
        
        for each neighbor in current.neighbors:
            tentative_g_score = g_score[current] + distance(current, neighbor)
            if tentative_g_score < g_score.get(neighbor, infinity):
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, goal_node)
                if neighbor not in open_set:
                    open_set.add(neighbor)
    \end{lstlisting}
    \end{block}
    \begin{block}{Python Implementation}
    \begin{lstlisting}[language=Python]
import heapq

def astar(graph, start, goal, heuristic):
    open_set = []
    heapq.heappush(open_set, (0, start))
    came_from = {}
    g_score = {node: float('inf') for node in graph}
    g_score[start] = 0
    f_score = {node: float('inf') for node in graph}
    f_score[start] = heuristic(start, goal)

    while open_set:
        current = heapq.heappop(open_set)[1]

        if current == goal:
            return reconstruct_path(came_from, current)

        for neighbor in graph[current]:
            tentative_g_score = g_score[current] + graph[current][neighbor]
            if tentative_g_score < g_score[neighbor]:
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, goal)
                if neighbor not in [i[1] for i in open_set]:
                    heapq.heappush(open_set, (f_score[neighbor], neighbor))

    return None  # Path not found
    \end{lstlisting}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Summary}
    \begin{itemize}
        \item \textbf{BFS}: Best for unweighted shortest path searches; queue based.
        \item \textbf{DFS}: Useful for deep explorations; can be recursive or stack based.
        \item \textbf{A*}: Efficient pathfinding with heuristic guidance; utilizes priority queues.
    \end{itemize}
    \begin{block}{Key Takeaway}
        Ensure understanding of concepts and practice coding these algorithms to reinforce learning!
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Comparative Analysis of Implementations}
    \begin{block}{Overview}
        Analyzing the effectiveness of three search algorithms:
        \begin{itemize}
            \item Breadth-First Search (BFS)
            \item Depth-First Search (DFS)
            \item A*
        \end{itemize}
        Identify strengths, weaknesses, and applicable scenarios for each.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Learning Objectives}
    \begin{itemize}
        \item Understand performance metrics of different search algorithms.
        \item Compare efficiency in time and space complexity.
        \item Review specific use-case scenarios for each algorithm.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Points of Comparison}
    \begin{enumerate}
        \item \textbf{Time Complexity}:
        \begin{itemize}
            \item BFS: $O(b^d)$
            \item DFS: $O(b^d)$ (more affected by depth)
            \item A*: $O(b^d)$ (typically better with a good heuristic)
        \end{itemize}
        
        \item \textbf{Space Complexity}:
        \begin{itemize}
            \item BFS: $O(b^d)$ (stores all nodes at the current depth)
            \item DFS: $O(b \cdot d)$ (stores only the current path)
            \item A*: $O(b^d)$ (depends on heuristic)
        \end{itemize}
        
        \item \textbf{Optimality}:
        \begin{itemize}
            \item BFS: Guaranteed to find the shortest path.
            \item DFS: Not guaranteed.
            \item A*: Guaranteed with an admissible heuristic.
        \end{itemize}
        
        \item \textbf{Completeness}:
        \begin{itemize}
            \item BFS: Complete.
            \item DFS: Not complete in infinite trees.
            \item A*: Complete with an admissible heuristic.
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Example Scenarios}
    \begin{itemize}
        \item \textbf{BFS}: Best for unweighted graphs (e.g., social networks).
        \item \textbf{DFS}: Ideal for memory constraint scenarios (e.g., mazes).
        \item \textbf{A*}: Preferred for pathfinding with known costs (e.g., games).
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Conclusion}
    \begin{block}{Choosing an Algorithm}
        Consider:
        \begin{itemize}
            \item Nature of the problem (unweighted vs weighted).
            \item Constraints on memory and time.
            \item Required optimality and completeness.
        \end{itemize}
        Understanding these factors will help in selecting the right algorithm for performance and efficiency.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Code Snippets}
    \begin{block}{BFS Pseudocode}
    \begin{lstlisting}[language=Python]
def bfs(graph, start):
    visited = []
    queue = [start]

    while queue:
        node = queue.pop(0)
        if node not in visited:
            visited.append(node)
            queue.extend(neighbor for neighbor in graph[node] if neighbor not in visited)
    return visited
    \end{lstlisting}
    \end{block}

    \begin{block}{A* Pseudocode}
    \begin{lstlisting}[language=Python]
def a_star(start, goal, graph, heuristic):
    open_set = set([start])
    came_from = {}
    g_score = {start: 0}
    f_score = {start: heuristic(start, goal)}

    while open_set:
        current = min(open_set, key=lambda x: f_score.get(x, float('inf')))

        if current == goal:
            return reconstruct_path(came_from, current)

        open_set.remove(current)
        for neighbor in graph[current]:
            tentative_g_score = g_score[current] + graph[current][neighbor]

            if tentative_g_score < g_score.get(neighbor, float('inf')):
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, goal)
                open_set.add(neighbor)

    return False  # Failure: no path found
    \end{lstlisting}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Common Pitfalls in Search Algorithms}
    \begin{block}{Introduction}
        When implementing search algorithms, mistakes can arise, compromising performance or correctness. This presentation highlights common pitfalls along with practical tips to avoid them.
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Key Pitfalls in Search Algorithms}
    \begin{enumerate}
        \item \textbf{Ignoring Edge Cases}
        \item \textbf{Assuming Sorted Inputs}
        \item \textbf{Overlooking Time Complexity}
        \item \textbf{Failing to Understand Algorithm Requirements}
        \item \textbf{Neglecting the Importance of Data Structures}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Detailed Pitfalls and Tips}
    \begin{itemize}
        \item \textbf{Ignoring Edge Cases:}
            \begin{itemize}
                \item Many implementations overlook special cases.
                \item E.g., failing to handle empty arrays in binary search.
                \item \textit{Tip: Always test your algorithms with edge cases.}
            \end{itemize}
            
        \item \textbf{Assuming Sorted Inputs:}
            \begin{itemize}
                \item Binary search requires sorted data.
                \item Unsorted data leads to invalid results.
                \item \textit{Tip: Confirm data is sorted beforehand.}
            \end{itemize}
            
        \item \textbf{Overlooking Time Complexity:}
            \begin{itemize}
                \item Inefficient algorithms can lead to performance issues.
                \item E.g., using linear search (O(n)) on large datasets.
                \item \textit{Tip: Choose the most efficient algorithm based on problem context.}
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Detailed Pitfalls and Tips (cont.)}
    \begin{itemize}
        \item \textbf{Failing to Understand Algorithm Requirements:}
            \begin{itemize}
                \item Algorithms have specific constraints for correct execution.
                \item E.g., DFS may cause infinite loops if the graph isn't connected.
                \item \textit{Tip: Read algorithm specifications carefully.}
            \end{itemize}
        
        \item \textbf{Neglecting the Importance of Data Structures:}
            \begin{itemize}
                \item Choice of data structure influences efficiency.
                \item E.g., searching in linked lists vs. arrays.
                \item \textit{Tip: Select data structures that complement the algorithm's needs.}
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Summary Points}
    \begin{itemize}
        \item \textbf{Review Algorithm Specifications:} Familiarize with requirements.
        \item \textbf{Test Edge Cases:} Ensure reliability and correctness.
        \item \textbf{Select the Right Data Structure:} Choose based on efficiency.
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Example: Binary Search with Edge Case}
    Here is a simple implementation that checks for edge cases:
    \begin{lstlisting}[language=Python]
def binary_search(arr, target):
    if not arr:
        return -1  # Edge case: empty list
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid  # Element found
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1  # Element not found
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Wrap-Up and Key Takeaways}
    \begin{block}{Overview of Search Algorithms}
        Search algorithms are fundamental components of computer science and data structures. 
        They efficiently retrieve information from larger datasets. 
        This chapter highlighted several common search algorithms, their practical applications, 
        and how to avoid common pitfalls in their implementation.
    \end{block}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Key Types of Search Algorithms}
    \begin{enumerate}
        \item \textbf{Linear Search}
            \begin{itemize}
                \item \textbf{Concept}: Checks every element until the target is found or the entire list is searched.
                \item \textbf{Time Complexity}: O(n)
                \item \textbf{Example}: Finding a student ID in an unsorted list.
            \end{itemize}
        \item \textbf{Binary Search}
            \begin{itemize}
                \item \textbf{Concept}: Requires a sorted list; divides the search interval in half repeatedly.
                \item \textbf{Time Complexity}: O(log n)
                \item \textbf{Example}: Searching for a book title in a sorted catalog.
            \end{itemize}
        \item \textbf{Depth-First Search (DFS)}
            \begin{itemize}
                \item \textbf{Concept}: Explores as far as possible along a branch before backtracking.
                \item \textbf{Use Case}: Used in puzzles, maze navigation.
                \item \textbf{Example}: Finding a path in a maze.
            \end{itemize}
        \item \textbf{Breadth-First Search (BFS)}
            \begin{itemize}
                \item \textbf{Concept}: Explores all neighbor nodes at the present depth before moving deeper.
                \item \textbf{Use Case}: Shortest path in unweighted graphs, web crawlers.
                \item \textbf{Example}: Finding the shortest route on a map.
            \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Practical Applications and Common Pitfalls}
    \begin{block}{Practical Applications}
        \begin{itemize}
            \item \textbf{Data Retrieval}: Effective querying techniques in databases.
            \item \textbf{Web Searches}: Utilizing advanced techniques for quicker, accurate results.
            \item \textbf{Navigation Systems}: BFS in GPS routing for optimal paths.
        \end{itemize}
    \end{block}
    
    \begin{block}{Common Pitfalls}
        \begin{itemize}
            \item \textbf{Incorrect Assumptions}: Not all cases are suited for linear search; binary search is better for sorted data.
            \item \textbf{Inefficient Scanning}: Choose the most optimized algorithm based on sorted/unsorted context.
        \end{itemize}
    \end{block}
    
    \begin{block}{Final Thoughts}
        Mastering search algorithms is crucial for efficient programming and data manipulation.
        Applying the right technique enhances performance and improves user experience.
    \end{block}
    
    \begin{block}{What's Next?}
        Prepare for a Q\&A session to explore these algorithms further and clarify any questions!
    \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Q\&A Session - Opening the Floor}
  This slide provides an opportunity for students to pose questions, seek clarifications, and engage in deeper discussions about the concepts presented in the previous slides regarding search algorithms. 
  \begin{itemize}
      \item Feel free to ask questions related to:
      \begin{itemize}
          \item Fundamental concepts
          \item Practical applications
          \item Specific algorithms discussed earlier
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Q\&A Session - Key Concepts Recap}
  To ground our discussion, let us quickly summarize a few key concepts covered in the chapter:
  \begin{enumerate}
      \item \textbf{Search Algorithms}: Techniques used to find specific data within a data structure or a dataset.
      \item \textbf{Types of Search Algorithms}:
      \begin{itemize}
          \item \textbf{Linear Search}: Checks each element until the desired element is found.
          \item \textbf{Binary Search}: Efficient algorithm requiring sorted data, divides the search interval in half.
          \item \textbf{Depth-First Search (DFS)}: Explores as far as possible down one branch before backtracking.
          \item \textbf{Breadth-First Search (BFS)}: Explores all neighbor nodes at the present depth before moving deeper.
      \end{itemize}
  \end{enumerate}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Q\&A Session - Sample Questions}
  Here are some example questions to stimulate our discussion:
  \begin{itemize}
      \item \textbf{Time Complexity Comparison}:
      \begin{itemize}
          \item Can you explain how the time complexity of binary search compares to linear search?
          \item \textbf{Key Point}: Binary search has a time complexity of \(O(\log n)\) compared to \(O(n)\) for linear search.
      \end{itemize}
      \item \textbf{Real-World Applications}:
      \begin{itemize}
          \item What are some real-world applications of search algorithms?
          \item \textbf{Illustration}: Fundamental to systems like search engines, databases, and network routing protocols.
      \end{itemize}
      \item \textbf{Choice of Data Structure}:
      \begin{itemize}
          \item How does the choice of data structure affect the efficiency of a search algorithm?
          \item \textbf{Key Point}: Data structures like arrays, linked lists, trees, and hash tables impact algorithm performance.
      \end{itemize}
  \end{itemize}
\end{frame}


\end{document}